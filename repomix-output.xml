This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: Assets/Elements/**/*.cs
- Files matching these patterns are excluded: Library/, Temp/, Obj/, Build/, Builds/, Logs/, *.log, *.tmp, *.bak, *.cache, *.csproj, *.sln, *.user, *.unityproj, *.pidb, *.booproj, *.svd, *.pdb, *.mdb, *.opendb, *.VC.db, *.pidb.meta, *.pdb.meta, *.mdb.meta, *.opendb.meta, *.VC.db.meta
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
Assets/
  Elements/
    _TrackSystem/
      Scripts/
        BiomeDefinition.cs
        BiomeManager.cs
        LevelGenerator.cs
        PoolManager.cs
        ScenerySpawner.cs
        SpawnableElement.cs
        TrackSpawner.cs
    Audio/
      AudioManager.cs
    Camera/
      CameraController.cs
    Coin/
      Coin.cs
      CoinText.cs
    GeneralScripts/
      Sound.cs
    Generator/
      Generator.cs
    Godmode/
      Sugar.cs
    Ground/
      Spike/
        Spike.cs
      BiomeModule.cs
      Ground.cs
      SpawnCoins.cs
      SpawnObstacles.cs
    Juice/
      Juice.cs
    LevelEnd/
      AdsInitializer.cs
      LevelEnd.cs
      UnityBannerAd.cs
      UnityInterstitialAd.cs
      UnityRewardedAd.cs
    Other/
      FpsManager.cs
    SmurfCat/
      SmurfCatMovement.cs
    UI/
      Scripts/
        BeforePlayOverlay.cs
        LevelsMenu.cs
        LoadingScene.cs
        MainMenu.cs
        NextLevel.cs
        PauseMenu.cs
      UITimer.cs
    VFXs/
      FollowPlayer.cs
    MoveForward.cs
    SpeedManager.cs
    TutorialItem.cs

================================================================
Files
================================================================

================
File: Assets/Elements/_TrackSystem/Scripts/BiomeDefinition.cs
================
using UnityEngine;
using System.Collections.Generic;
using JetBrains.Annotations;

[CreateAssetMenu(fileName = "NewBiomeDefinition", menuName = "Gameplay/Biome Definition")]
public class BiomeDefinition : ScriptableObject
{
    [Header("Identification")]
    public string biomeName = "Unnamed Biome";
    public Color biomeDebugColor = Color.white; // Para Gizmos ou UI

    [Header("Visuals")]
    public Material skyboxMaterial;
    [CanBeNull] public GameObject environmentParticlePrefab; // Partículas de ambiente do bioma

    [Header("Spawning Rules")]
    public int modulesBeforeTransition = 10; // Quantos módulos de *cenário* gerar antes de talvez mudar

    [Header("Spawnable Prefabs")]
    // Lista de prefabs de *Cenário* que podem aparecer neste bioma
    public List<GameObject> sceneryPrefabs;

    // Lista de prefabs de *Pistas* que podem aparecer neste bioma
    public List<GameObject> trackPrefabs;

    // --- Opcional: Usar SOs para Cenários/Pistas ---
    // public List<SpawnableItemDefinition> sceneryDefinitions;
    // public List<SpawnableItemDefinition> trackDefinitions;
    // --- Fim Opcional ---

    [Header("Gameplay Modifiers (Optional)")]
    public float speedMultiplier = 1.0f;
    // Outros modificadores: dificuldade, tipos de inimigos/obstáculos permitidos, etc.
}

================
File: Assets/Elements/_TrackSystem/Scripts/BiomeManager.cs
================
using UnityEngine;
using System.Collections.Generic;
using System; // Para Action

public class BiomeManager : MonoBehaviour
{
    [SerializeField] private List<BiomeDefinition> availableBiomes;
    [SerializeField] private float transitionDelay = 2.0f; // Tempo para animação de UI, etc.

    public BiomeDefinition CurrentBiome { get; private set; }
    private int currentBiomeIndex = -1;
    private int modulesSpawnedInCurrentBiome = 0;

    public static event Action<BiomeDefinition> OnBiomeWillChange; // Avisa *antes* da transição (para UI/FX)
    public static event Action<BiomeDefinition> OnBiomeChanged; // Avisa *depois* da transição

    void Start()
    {
        if (availableBiomes == null || availableBiomes.Count == 0)
        {
            Debug.LogError("Nenhum bioma disponível configurado no BiomeManager!");
            this.enabled = false;
            return;
        }
        // Começa com o primeiro bioma sem transição visual imediata
        ForceSetBiome(0);
        ApplyBiomeSettings(CurrentBiome); // Aplica configurações iniciais
    }

    // Chamado pelo LevelGenerator quando um módulo de cenário é spawnado
    public void NotifySceneryModuleSpawned()
    {
        modulesSpawnedInCurrentBiome++;
        CheckForBiomeTransition();
    }

    private void CheckForBiomeTransition()
    {
        if (CurrentBiome == null) return;

        if (modulesSpawnedInCurrentBiome >= CurrentBiome.modulesBeforeTransition)
        {
            // Lógica para decidir se muda (pode ser aleatório, sequencial, etc.)
            // Exemplo simples: sempre muda sequencialmente
            int nextBiomeIndex = (currentBiomeIndex + 1) % availableBiomes.Count;
            StartCoroutine(TransitionToBiomeCoroutine(nextBiomeIndex));
        }
    }

    private System.Collections.IEnumerator TransitionToBiomeCoroutine(int nextBiomeIndex)
    {
        if (nextBiomeIndex == currentBiomeIndex) yield break; // Já está no bioma

        BiomeDefinition nextBiome = availableBiomes[nextBiomeIndex];

        OnBiomeWillChange?.Invoke(nextBiome); // Dispara evento *antes* da mudança

        // --- Aqui você pode adicionar a animação de UI do nome do bioma ---
        // Ex: biomeTextAnimator.Show(nextBiome.biomeName, nextBiome.biomeColor);
        Debug.Log($"Transitioning to Biome: {nextBiome.biomeName}");
        yield return new WaitForSeconds(transitionDelay); // Espera a animação/delay

        ForceSetBiome(nextBiomeIndex);
        ApplyBiomeSettings(CurrentBiome);

        OnBiomeChanged?.Invoke(CurrentBiome); // Dispara evento *depois* da mudança
        modulesSpawnedInCurrentBiome = 0; // Reseta contador para o novo bioma
    }

    private void ForceSetBiome(int index)
    {
        if (index < 0 || index >= availableBiomes.Count) return;
        currentBiomeIndex = index;
        CurrentBiome = availableBiomes[currentBiomeIndex];
        Debug.Log($"Biome set to: {CurrentBiome.biomeName}");
    }

    // Aplica as configurações visuais/gameplay do bioma
    private void ApplyBiomeSettings(BiomeDefinition biome)
    {
        if (biome == null) return;

        // Skybox
        if (biome.skyboxMaterial != null)
        {
            RenderSettings.skybox = biome.skyboxMaterial;
            DynamicGI.UpdateEnvironment(); // Atualiza iluminação global se necessário
        }
        else
        {
            RenderSettings.skybox = null; // Ou um skybox padrão
        }

        // Partículas (Você precisará de um sistema para gerenciar/ativar/desativar)
        // Ex: EnvironmentParticleManager.Instance.SetBiomeParticles(biome.environmentParticlePrefab);

        // Modificadores de Gameplay (ex: velocidade global)
        // Ex: SpeedManager.SetBiomeSpeedMultiplier(biome.speedMultiplier);
    }

    // Método para obter uma lista de prefabs de cenário válidos para o bioma atual
    public List<GameObject> GetValidSceneryPrefabs()
    {
        return CurrentBiome?.sceneryPrefabs ?? new List<GameObject>();
    }

    // Método para obter uma lista de prefabs de pista válidos para o bioma atual
    public List<GameObject> GetValidTrackPrefabs()
    {
        return CurrentBiome?.trackPrefabs ?? new List<GameObject>();
    }
}

================
File: Assets/Elements/_TrackSystem/Scripts/LevelGenerator.cs
================
using UnityEngine;

public class LevelGenerator : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private Transform playerTransform;
    [SerializeField] private BiomeManager biomeManager;
    [SerializeField] private ScenerySpawner scenerySpawner;
    [SerializeField] private TrackSpawner trackSpawner;
    [SerializeField] private PoolManager poolManager; // Para cleanup

    [Header("Generation Triggering")]
    [SerializeField] private float generationDistanceThreshold = 150f; // Distância à frente do jogador para gerar
    [SerializeField] private float cleanupDistanceBehind = 200f; // Distância atrás para limpar

    private float furthestPointGeneratedZ = 0f;

    void Start()
    {
        if (!ValidateReferences()) return;
        // Gera o conteúdo inicial
        GenerateInitialContent();
    }

    void Update()
    {
        if (playerTransform == null) return;

        // Verifica se precisa gerar mais conteúdo
        if (furthestPointGeneratedZ - playerTransform.position.z < generationDistanceThreshold)
        {
            GenerateNextSection();
        }

        // Verifica se precisa limpar conteúdo antigo (simplificado)
        // Uma abordagem mais robusta seria rastrear os objetos ativos
        CleanupOldContent();
    }

    private bool ValidateReferences()
    {
        bool valid = true;
        if (playerTransform == null) { Debug.LogError("Player Transform not set!"); valid = false; }
        if (biomeManager == null) { Debug.LogError("Biome Manager not set!"); valid = false; }
        if (scenerySpawner == null) { Debug.LogError("Scenery Spawner not set!"); valid = false; }
        if (trackSpawner == null) { Debug.LogError("Track Spawner not set!"); valid = false; }
        if (poolManager == null) { Debug.LogError("Pool Manager not set!"); valid = false; }
        return valid;
    }

    private void GenerateInitialContent()
    {
        // Gera algumas seções iniciais para preencher o espaço
        for (int i = 0; i < 2; i++) // Gera 5 seções iniciais, por exemplo
        {
            GenerateNextSection();
            // Ajusta artificialmente a posição para forçar a geração sequencial no início
            // (Ou melhore a lógica de `GenerateNextSection` para lidar com o caso inicial)
            if(scenerySpawner.LastSpawnedScenery != null)
                furthestPointGeneratedZ = scenerySpawner.LastSpawnedScenery.endAttachPoint.position.z - generationDistanceThreshold * 0.5f;
        }
         // Após gerar o conteúdo inicial, reseta furthestPointGeneratedZ para o valor correto
        if (scenerySpawner.LastSpawnedScenery != null && scenerySpawner.LastSpawnedScenery.endAttachPoint != null)
        {
            furthestPointGeneratedZ = scenerySpawner.LastSpawnedScenery.endAttachPoint.position.z;
        }
        else
        {
             furthestPointGeneratedZ = 0f; // Valor inicial se nada foi gerado
             Debug.LogWarning("Nenhum cenário inicial gerado ou sem attach point.");
        }
    }

    private void GenerateNextSection()
    {
        // 1. Gera o próximo módulo de cenário
        GameObject newScenery = scenerySpawner.SpawnNextScenery();
        if (newScenery == null)
        {
            Debug.LogError("Falha ao gerar novo cenário!");
            return;
        }

        // 2. Gera as pistas paralelas para *este* cenário
        trackSpawner.SpawnTracksForScenery(newScenery);

        // 3. Atualiza o ponto mais distante gerado
        SpawnableElement sceneryElement = newScenery.GetComponent<SpawnableElement>();
        if (sceneryElement != null && sceneryElement.endAttachPoint != null)
        {
            furthestPointGeneratedZ = sceneryElement.endAttachPoint.position.z;
            // Debug.Log($"Nova seção gerada. Furthest Z: {furthestPointGeneratedZ}");
        }
        else
        {
            // Fallback: estima baseado no tamanho do objeto se não houver attach point
            Renderer rend = newScenery.GetComponentInChildren<Renderer>();
            if(rend != null)
                furthestPointGeneratedZ += rend.bounds.size.z; // Estimativa grosseira
            else
                 furthestPointGeneratedZ += 50f; // Valor padrão

            Debug.LogWarning($"Scenery '{newScenery.name}' não tem SpawnableElement ou endAttachPoint configurado. Estimando Z.");
        }

         // 4. Notifica o BiomeManager sobre o spawn do cenário (para transição)
        biomeManager.NotifySceneryModuleSpawned();
    }

    private void CleanupOldContent()
    {
        float cleanupPosZ = playerTransform.position.z - cleanupDistanceBehind;

        // Limpa pistas e cenários antigos
        scenerySpawner.CleanupActiveScenery(cleanupPosZ);
        trackSpawner.CleanupActiveTracks(cleanupPosZ);
    }
}

================
File: Assets/Elements/_TrackSystem/Scripts/PoolManager.cs
================
using UnityEngine;
using System.Collections.Generic;

public class PoolManager : MonoBehaviour
{
    public static PoolManager Instance { get; private set; }

    [System.Serializable]
    public class Pool
    {
        public GameObject prefab;
        public int initialSize;
        [HideInInspector] public Queue<GameObject> objects = new Queue<GameObject>();
    }

    [SerializeField] private List<Pool> pools; // Configure os prefabs de Cenário e Pista aqui no Inspector
    private Dictionary<int, Pool> poolDictionary = new Dictionary<int, Pool>();

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        InitializePools();
    }

    private void InitializePools()
    {
        foreach (Pool pool in pools)
        {
            int prefabId = pool.prefab.GetInstanceID();
            if (!poolDictionary.ContainsKey(prefabId))
            {
                poolDictionary.Add(prefabId, pool);
                for (int i = 0; i < pool.initialSize; i++)
                {
                    AddNewObjectToPool(pool);
                }
            }
            else
            {
                Debug.LogWarning($"Pool for prefab '{pool.prefab.name}' already exists.");
            }
        }
    }

    private GameObject AddNewObjectToPool(Pool pool)
    {
        GameObject obj = Instantiate(pool.prefab, transform); // Instancia como filho do PoolManager
        obj.SetActive(false); // Começa desativado
        pool.objects.Enqueue(obj);

        // Adiciona/Obtém o componente SpawnableElement
        SpawnableElement spawnable = obj.GetComponent<SpawnableElement>();
        if (spawnable == null)
        {
            spawnable = obj.AddComponent<SpawnableElement>();
        }
        spawnable.Initialize(pool.prefab.GetInstanceID()); // Passa o ID do prefab original

        return obj;
    }

    public GameObject Get(GameObject prefab, Vector3 position, Quaternion rotation)
    {
        int id = prefab.GetInstanceID();
        if (!poolDictionary.ContainsKey(id))
        {
            Debug.LogError($"Pool for prefab '{prefab.name}' not found!");
            return null; // Ou talvez instanciar um novo se for preferível?
        }

        Pool pool = poolDictionary[id];
        GameObject objToSpawn;

        if (pool.objects.Count > 0)
        {
            objToSpawn = pool.objects.Dequeue();
        }
        else
        {
            // Pool vazia, cria um novo objeto
            Debug.LogWarning($"Pool for '{prefab.name}' empty. Creating new instance.");
            objToSpawn = AddNewObjectToPool(pool);
            // Dequeue o objeto recém-adicionado (já que AddNewObjectToPool o enfileira)
            if (pool.objects.Contains(objToSpawn)) // Verifica se está na fila antes de tentar desenfileirar
               pool.objects.Dequeue(); // Remove da fila, pois será ativado agora
            else
               Debug.LogError("Inconsistência no pool após adicionar novo objeto.");

        }

        objToSpawn.transform.position = position;
        objToSpawn.transform.rotation = rotation;
        // objToSpawn.SetActive(true); // NÃO ativar aqui, deixa o SpawnableElement fazer isso com animação

        // Chama a animação de spawn via SpawnableElement
        SpawnableElement spawnable = objToSpawn.GetComponent<SpawnableElement>();
        spawnable?.PlaySpawnAnimation(); // O SpawnableElement cuidará de ativar o objeto

        return objToSpawn;
    }

     public void Return(GameObject obj)
    {
        SpawnableElement spawnable = obj.GetComponent<SpawnableElement>();
        if (spawnable == null)
        {
            Debug.LogError($"Object '{obj.name}' being returned to pool doesn't have SpawnableElement!");
            obj.SetActive(false); // Desativa de qualquer forma
            // Potencialmente destruir se não for gerenciável?
            return;
        }

        // Usa o ID armazenado para encontrar o pool correto
        int id = spawnable.PrefabID;
        if (poolDictionary.ContainsKey(id))
        {
            Pool pool = poolDictionary[id];

             // Inicia animação de despawn e retorna ao pool no final
            spawnable.PlayDespawnAnimation(() =>
            {
                 if (obj != null) // Verifica se o objeto ainda existe
                 {
                      // Garante que o objeto está realmente desativado antes de enfileirar
                     obj.SetActive(false);
                     obj.transform.SetParent(transform); // Garante que volte a ser filho do PoolManager
                     pool.objects.Enqueue(obj);
                 }
            });
        }
        else
        {
            Debug.LogError($"Trying to return object '{obj.name}' to a pool that doesn't exist (PrefabID: {id})!");
            // Se não pertence a nenhum pool conhecido, apenas desativa ou destrói
             obj.SetActive(false);
            // Destroy(obj); // Descomente se quiser destruir objetos não pertencentes a pools
        }
    }
}

================
File: Assets/Elements/_TrackSystem/Scripts/ScenerySpawner.cs
================
using UnityEngine;
using System.Collections.Generic;

public class ScenerySpawner : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private BiomeManager biomeManager;
    [SerializeField] private PoolManager poolManager;
    [SerializeField] private Transform sceneryParent; // Opcional: pai para organizar na hierarquia

    [Header("Spawning Logic")]
    [SerializeField] private Vector2 xSpawnRange = new Vector2(-20f, 20f); // Faixa de spawn em X
    [SerializeField] private Vector2 zSpawnOffsetRange = new Vector2(50f, 150f); // Offset em Z
    [SerializeField] private Vector2 ySpawnRange = new Vector2(-2f, 2f); // Variação em Y

    private List<GameObject> activeScenery = new List<GameObject>();

    public SpawnableElement LastSpawnedScenery { get; private set; }

    public void TrySpawnScenery(Vector3 referencePosition)
    {
        if (biomeManager.CurrentBiome == null) return;

        List<GameObject> validPrefabs = biomeManager.GetValidSceneryPrefabs();
        if (validPrefabs.Count == 0) return;

        // Decide aleatoriamente se deve spawnar um cenário decorativo
        if (Random.value > 0.5f) return;

        // Seleciona um prefab aleatório
        GameObject prefabToSpawn = validPrefabs[Random.Range(0, validPrefabs.Count)];

        // Calcula a posição de spawn
        float xOffset = Random.Range(xSpawnRange.x, xSpawnRange.y);
        float zOffset = Random.Range(zSpawnOffsetRange.x, zSpawnOffsetRange.y);
        float yOffset = Random.Range(ySpawnRange.x, ySpawnRange.y);

        Vector3 spawnPosition = referencePosition + new Vector3(xOffset, yOffset, zOffset);

        // Pede ao PoolManager
        GameObject newSceneryObject = poolManager.Get(prefabToSpawn, spawnPosition, Quaternion.identity);
        if (newSceneryObject == null) return;

        if (sceneryParent != null)
            newSceneryObject.transform.SetParent(sceneryParent);

        activeScenery.Add(newSceneryObject);
    }

    public void CleanupActiveScenery(float cleanupPosZ)
    {
        for (int i = activeScenery.Count - 1; i >= 0; i--)
        {
            GameObject scenery = activeScenery[i];
            if (scenery != null && scenery.activeSelf && scenery.transform.position.z < cleanupPosZ)
            {
                poolManager.Return(scenery);
                activeScenery.RemoveAt(i);
            }
            else if (scenery == null)
            {
                activeScenery.RemoveAt(i);
            }
        }
    }

    public GameObject SpawnNextScenery()
    {
        if (biomeManager == null || poolManager == null)
        {
            Debug.LogError("BiomeManager ou PoolManager não estão definidos!");
            return null;
        }

        if (biomeManager.CurrentBiome == null)
        {
            Debug.LogWarning("Nenhum bioma atual definido.");
            return null;
        }

        List<GameObject> validPrefabs = biomeManager.GetValidSceneryPrefabs();
        if (validPrefabs == null || validPrefabs.Count == 0)
        {
            Debug.LogWarning("Nenhum prefab de cenário válido encontrado.");
            return null;
        }

        GameObject selectedPrefab = validPrefabs[Random.Range(0, validPrefabs.Count)];
        Vector3 spawnPosition = Vector3.zero;

        if (LastSpawnedScenery != null && LastSpawnedScenery.endAttachPoint != null)
        {
            spawnPosition = LastSpawnedScenery.endAttachPoint.position;
        }

        GameObject newSceneryObject = poolManager.Get(selectedPrefab, spawnPosition, Quaternion.identity);
        if (newSceneryObject == null)
        {
            Debug.LogError("Falha ao obter objeto do PoolManager!");
            return null;
        }

        SpawnableElement spawnable = newSceneryObject.GetComponent<SpawnableElement>();
         LastSpawnedScenery = spawnable;

        if (sceneryParent != null)
        {
            newSceneryObject.transform.SetParent(sceneryParent);
        }

        activeScenery.Add(newSceneryObject);
        return newSceneryObject;
    }
}

================
File: Assets/Elements/_TrackSystem/Scripts/SpawnableElement.cs
================
using UnityEngine;
using DG.Tweening;
using System; // Para Action

public class SpawnableElement : MonoBehaviour
{
    [Header("Animation Settings")]
    [SerializeField] private bool animateSpawn = true;
    [SerializeField] private Vector3 initialScaleMultiplier = Vector3.one * 1.5f; // Começa um pouco maior
    [SerializeField] private float spawnDuration = 0.6f;
    [SerializeField] private Ease spawnEase = Ease.OutBack;

    [SerializeField] private bool animateDespawn = true;
    [SerializeField] private float despawnDuration = 0.4f;
    [SerializeField] private Ease despawnEase = Ease.InBack;

    [Header("Attach Points (Scenery Only)")]
    public Transform endAttachPoint; // Ponto onde o próximo cenário se conecta

    private Vector3 baseScale;
    private Tween currentTween;
    private Collider[] colliders; // Cache dos colliders

    public int PrefabID { get; private set; } // ID do prefab original (para pooling)

    void Awake()
    {
        baseScale = transform.localScale;
        colliders = GetComponentsInChildren<Collider>(true); // Inclui inativos
    }

    // Chamado pelo PoolManager para identificar a qual pool pertence
    public void Initialize(int prefabID)
    {
        PrefabID = prefabID;
    }

    public void PlaySpawnAnimation()
    {
        // Garante que está desativado se já estiver ativo (reinício)
        gameObject.SetActive(false);

        // Cancela tweens anteriores
        currentTween?.Kill();

        // Prepara para spawn
        SetCollidersEnabled(false); // Desativa colliders durante a animação
        transform.localScale = baseScale * initialScaleMultiplier.x; // Aplica multiplicador inicial (ou Vector3.zero se preferir pop-in)

        gameObject.SetActive(true); // Ativa o GameObject ANTES de iniciar o DOTween

        if (animateSpawn)
        {
             currentTween = transform.DOScale(baseScale, spawnDuration)
                .SetEase(spawnEase)
                .SetUpdate(true) // Garante que funcione mesmo se o Time.timeScale for 0 (útil para hitstop?)
                .OnComplete(OnSpawnComplete);
        }
        else
        {
            transform.localScale = baseScale;
            OnSpawnComplete();
        }
    }

     public void PlayDespawnAnimation(Action onComplete)
    {
        // Cancela tweens anteriores
        currentTween?.Kill();
        SetCollidersEnabled(false); // Desativa colliders

        if (animateDespawn)
        {
            currentTween = transform.DOScale(Vector3.zero, despawnDuration)
                .SetEase(despawnEase)
                .SetUpdate(true)
                .OnComplete(() => {
                    // Reset scale for the pool before calling completion callback
                    transform.localScale = baseScale;
                    onComplete?.Invoke();
                 });
        }
        else
        {
             // Reset scale for the pool before calling completion callback
            transform.localScale = baseScale;
            onComplete?.Invoke();
        }
    }

    private void OnSpawnComplete()
    {
        SetCollidersEnabled(true); // Reativa colliders após a animação
        currentTween = null;
        // Debug.Log($"{gameObject.name} spawn complete.");
    }

     // Helper para ativar/desativar colliders
    private void SetCollidersEnabled(bool enabled)
    {
        if(colliders == null) return;
        foreach (var col in colliders)
        {
            if (col != null) col.enabled = enabled;
        }
    }

    // Garante que o tween seja cancelado se o objeto for destruído abruptamente
    void OnDestroy()
    {
        currentTween?.Kill();
    }
}

================
File: Assets/Elements/_TrackSystem/Scripts/TrackSpawner.cs
================
using UnityEngine;
using System.Collections.Generic;

public class TrackSpawner : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private BiomeManager biomeManager;
    [SerializeField] private PoolManager poolManager;
    [SerializeField] private Transform tracksParent; // Opcional

    [Header("Spawning Logic")]
    [SerializeField] private int parallelTrackCount = 3; // Deve ser ímpar para ter uma pista central
    [SerializeField] private float trackSpacing = 5.0f;  // Espaçamento horizontal entre pistas

    [SerializeField] private List<GameObject> activeTracks = new List<GameObject>();

    public void SpawnTracksForScenery(GameObject sceneryModule)
    {
        if (biomeManager.CurrentBiome == null || sceneryModule == null) return;

        List<GameObject> validPrefabs = biomeManager.GetValidTrackPrefabs();
        if (validPrefabs.Count == 0)
        {
            Debug.LogWarning($"Nenhuma pista válida encontrada para o bioma {biomeManager.CurrentBiome.biomeName}");
            return;
        }

        // Posição central do cenário como referência para as pistas paralelas
        Vector3 sceneryCenter = sceneryModule.transform.position;
        Quaternion sceneryRotation = sceneryModule.transform.rotation; // Usa a rotação do cenário

        int centerIndex = parallelTrackCount / 2; // Índice da pista central (funciona para ímpares)

        for (int i = 0; i < parallelTrackCount; i++)
        {
            // Seleciona um prefab de pista aleatório
            GameObject prefabToSpawn = validPrefabs[Random.Range(0, validPrefabs.Count)];

            // Calcula o deslocamento X relativo ao centro do cenário
            float xOffset = (i - centerIndex) * trackSpacing;

            // Calcula a posição final da pista no espaço do mundo
            // Aplica o offset localmente e depois transforma para world space
            Vector3 localOffset = new Vector3(xOffset, 0, 0); // Offset apenas no X local
            Vector3 spawnPosition = sceneryModule.transform.TransformPoint(localOffset);

            // Pede ao PoolManager
            GameObject newTrackObject = poolManager.Get(prefabToSpawn, spawnPosition, sceneryRotation);
             if (newTrackObject == null) continue; // Pula se o pool falhar

            // Define o pai (opcional)
            if (tracksParent != null)
                newTrackObject.transform.SetParent(tracksParent);

            activeTracks.Add(newTrackObject); // Adiciona à lista de ativos
        }
    }

    public void CleanupActiveTracks(float cleanupPosZ)
    {
        for (int i = activeTracks.Count - 1; i >= 0; i--)
        {
            GameObject track = activeTracks[i];
            if (track.transform.position.z < cleanupPosZ)
            {
                poolManager.Return(track); // Retorna ao pool
                activeTracks.RemoveAt(i); // Remove da lista
            }
        }
    }
}

================
File: Assets/Elements/GeneralScripts/Sound.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

[System.Serializable]
public class Sound : MonoBehaviour
{
    //Elements of the Audioclip that I want to be changeable
    public enum AudioTypes { sfx, music}
    public AudioTypes type;
    [HideInInspector] public AudioSource source;
    public string clipname;
    public AudioClip audioClip;
    public bool isLoop;
    public bool playOnAwake;
}

================
File: Assets/Elements/Godmode/Sugar.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Sugar : MonoBehaviour
{
   public static event Action OnSugarCollected;
    public GameObject sugarVFX, sugarContainer;
    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Character")
        {
            OnSugarCollected?.Invoke();
            GameObject sugarVFXInstance = Instantiate(sugarVFX, transform.position, Quaternion.identity);
            // ReparentVfx(sugarVFXInstance);
            Destroy(sugarVFXInstance, 1f);
            Destroy(gameObject);
        }
    }
    private void ReparentVfx(GameObject vfx)
    {
        vfx.transform.parent = sugarContainer.transform;
    }
}

================
File: Assets/Elements/Ground/BiomeModule.cs
================
using UnityEngine;

[SelectionBase] // Facilita seleção no Editor
public class BiomeModule : MonoBehaviour
{
    [Header("Module Settings")]
    [SerializeField] private Ground _ground;
    [SerializeField] private GameObject moduleEnd;
    [SerializeField] private Transform[] obstacleSpawnPoints;
    [SerializeField] private Transform[] decorationSpawnPoints;

    [Header("Biome Properties")]
    [SerializeField] private string biomeName;
    [SerializeField] private float difficulty = 1f;
    [SerializeField] private bool allowObstacles = true;

    public GameObject ModuleEnd => moduleEnd;
    public Transform[] ObstacleSpawnPoints => obstacleSpawnPoints;
    public Transform[] DecorationSpawnPoints => decorationSpawnPoints;
    public float Difficulty => difficulty;
    public bool AllowObstacles => allowObstacles;
    public Ground Ground => _ground;

    private void OnValidate()
    {
        if (moduleEnd == null)
        {
            Debug.LogError($"ModuleEnd is not set on BiomeModule {gameObject.name}");
        }
    }

    private void OnDrawGizmos()
    {
        // Draw spawn points for easier visualization in editor
        if (obstacleSpawnPoints != null)
        {
            Gizmos.color = Color.red;
            foreach (Transform point in obstacleSpawnPoints)
            {
                if (point != null)
                    Gizmos.DrawWireSphere(point.position, 0.5f);
            }
        }

        if (decorationSpawnPoints != null)
        {
            Gizmos.color = Color.green;
            foreach (Transform point in decorationSpawnPoints)
            {
                if (point != null)
                    Gizmos.DrawWireSphere(point.position, 0.3f);
            }
        }
    }
}

================
File: Assets/Elements/Ground/SpawnCoins.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SpawnCoins : MonoBehaviour
{
    [Header("Coin Settings")]
    public GameObject coinPrefab;
    public int numberOfCoins = 10;
    public float heightOffset = 1.0f;

    [Header("Ground Settings")]
    public Vector3 groundScale = new Vector3(10, 0.2f, 100);
    public float xSpacing = 2.0f;
    public float zSpacing = 5.0f;
    public float zStartOffset = 20.0f; // Start spawning coins further along Z-axis

    [Header("Spawn Timing")]
    public float spawnDelay = 1.0f; // Time to wait before spawning coins

    private List<GameObject> spawnedCoins = new List<GameObject>();

    public enum SpawnLayout
    {
        Ordered,
        Random,
        Lanes
    }

    private void Start()
    {
        // Select a random layout and start the delayed spawn
        SpawnLayout layout = (SpawnLayout)Random.Range(0, 3);
        // StartCoroutine(DelayedSpawn());
    }

    private IEnumerator DelayedSpawn()
    {
        
        SpawnLayout layout = (SpawnLayout)Random.Range(0, 3);
        // Wait for the specified delay time
        yield return new WaitForSeconds(spawnDelay);

        // Spawn the coins after the delay
        SpawnCoinsAboveGround(layout);
    }

    public void SpawnCoinsAboveGround(SpawnLayout layout)
    {
        // Reparent coinsHolder to groundsHolder (parent of this GameObject)
        GameObject groundsHolder = transform.parent.gameObject;

        // Calculate the spawn area bounds based on the ground's scale
        float halfWidth = groundScale.x / 2f;
        float halfLength = groundScale.z / 2f;

        int coinsSpawned = 0;

        // Loop to spawn coins within the ground's area
        for (float z = -halfLength + zStartOffset; z <= halfLength && coinsSpawned < numberOfCoins; z += zSpacing)
        {
            for (float x = -halfWidth; x <= halfWidth && coinsSpawned < numberOfCoins; x += xSpacing)
            {
                Vector3 spawnPosition = Vector3.zero;

                // Determine spawn position based on layout
                switch (layout)
                {
                    case SpawnLayout.Ordered:
                        // Ordered layout: coins in grid pattern
                        spawnPosition = new Vector3(
                            transform.position.x + x,
                            transform.position.y + heightOffset,
                            transform.position.z + z
                        );
                        break;

                    case SpawnLayout.Random:
                        // Random layout: randomize x within bounds
                        float randomX = Random.Range(-halfWidth, halfWidth);
                        spawnPosition = new Vector3(
                            transform.position.x + randomX,
                            transform.position.y + heightOffset,
                            transform.position.z + z
                        );
                        break;

                    case SpawnLayout.Lanes:
                        // Lanes layout: coins in three fixed lanes
                        float[] lanePositions = { -halfWidth / 2, 0, halfWidth / 2 };
                        float laneX = lanePositions[Random.Range(0, lanePositions.Length)];
                        spawnPosition = new Vector3(
                            transform.position.x + laneX,
                            transform.position.y + heightOffset,
                            transform.position.z + z
                        );
                        break;
                }

                // Instantiate the coin at the calculated position
                GameObject newCoin = Instantiate(coinPrefab, spawnPosition, Quaternion.identity);
                newCoin.transform.parent = groundsHolder.transform; // Set the coin's parent to groundsHolder
                spawnedCoins.Add(newCoin); // Track the spawned coin
                coinsSpawned++;
            }
        }
    }

    // Optional: Call this to clear previously spawned coins
    public void ClearSpawnedCoins()
    {
        foreach (var coin in spawnedCoins)
        {
            if (coin != null)
            {
                Destroy(coin);
            }
        }
        spawnedCoins.Clear();
    }
}

================
File: Assets/Elements/UI/Scripts/BeforePlayOverlay.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BeforePlayOverlay : MonoBehaviour
{
    void Start()
    {
        Time.timeScale = 0;
    }

}

================
File: Assets/Elements/UI/Scripts/LevelsMenu.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
public class LevelsMenu : MonoBehaviour
{
    public GameObject levelButtonsGameObject;
    public Button[] levelButtons;
    public void Awake(){
        AssignLevelButtons();
        UpdateLevelsAccess();
    }

    public void StartLevel(int levelId){
        string levelName = "Level" + levelId;
        SceneManager.LoadSceneAsync(levelName);
    }

    public void UpdateLevelsAccess(){
        int unlockedLevelsAmount = PlayerPrefs.GetInt("LevelsAmount", 2);
        for (int i = 0; i < levelButtons.Length; i++){
            if (i < unlockedLevelsAmount){
                levelButtons[i].interactable = true;
            } else {
                levelButtons[i].interactable = false;
            }
        }
    }

    public void AssignLevelButtons(){
        int levelsAmount = levelButtonsGameObject.transform.childCount;
        levelButtons = new Button[levelsAmount];
        for (int i = 0; i < levelButtons.Length; i++){
            levelButtons[i] = levelButtonsGameObject.transform.GetChild(i).GetComponent<Button>();
        }
    }
}

================
File: Assets/Elements/UI/Scripts/LoadingScene.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class LoadingScene : MonoBehaviour
{

    public GameObject loadingScreen;
    public Image loadingBar;

    void Start()
    {
        FakeLoadScene(1);
    }

    public void LoadScene(int sceneIndex)
    {
        StartCoroutine(LoadAsynchronously(sceneIndex));
    }

    public void FakeLoadScene(int sceneIndex)
    {
        StartCoroutine(FakeLoadAsynchronously(sceneIndex));
    }

    IEnumerator LoadAsynchronously(int sceneIndex)
    {
        loadingScreen.SetActive(true);
        AsyncOperation operation = SceneManager.LoadSceneAsync(sceneIndex);
        while (!operation.isDone)
        {
            float progress = Mathf.Clamp01(operation.progress / 0.9f);
            loadingBar.fillAmount = progress;
            yield return null;
        }
    }

    IEnumerator FakeLoadAsynchronously(int sceneIndex)
    {
        loadingScreen.SetActive(true);

        float timeToLoad = 5.0f;  // Total time to load in seconds
        float elapsedTime = 0.0f;
        float progress = 0.0f;
        float pauseTime = 1.0f;
        float pauseTimer = 0.0f;
        bool isPaused = false;

        while (elapsedTime < timeToLoad)
        {
            elapsedTime += Time.deltaTime;

            if (!isPaused)
            {
                // Update progress until it reaches 80%
                if (progress < 0.6f)
                {
                    progress = elapsedTime / timeToLoad;
                }

                // When progress reaches 80%, pause for 1 second
                if (progress >= 0.6f)
                {
                    isPaused = true;
                }
            }
            else
            {
                // Continue to pause for 1 second
                pauseTimer += Time.deltaTime;

                if (pauseTimer >= pauseTime)
                {
                    isPaused = false;
                }
            }

            loadingBar.fillAmount = progress;

            yield return null;
        }

        // Ensure the progress is exactly 100% before loading the scene
        loadingBar.fillAmount = 1.0f;

        // Load the scene after the fake loading is done
        AsyncOperation operation = SceneManager.LoadSceneAsync(sceneIndex);
        yield return operation;
    }


}

================
File: Assets/Elements/UI/Scripts/MainMenu.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class MainMenu : MonoBehaviour
{
    public void PlayGame(){
        SceneManager.LoadSceneAsync(1);
    }

    public void QuitGame(){
        Application.Quit();
    }

}

================
File: Assets/Elements/UI/Scripts/NextLevel.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class NextLevel : MonoBehaviour
{
    public void LoadNextLevel(int nextLevelId){
        SceneManager.LoadSceneAsync(nextLevelId);
    }

}

================
File: Assets/Elements/VFXs/FollowPlayer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FollowPlayer : MonoBehaviour
{
    public GameObject player;
    public float yOffset = 1.0f;
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        // Follows the player with an y offset
        transform.position = new Vector3(transform.position.x, player.transform.position.y + yOffset, transform.position.z);
        
    }
}

================
File: Assets/Elements/Coin/Coin.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Coin : MonoBehaviour
{
    public static event Action OnCoinCollected;
    public GameObject coinVFX;
    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Character")
        {
            OnCoinCollected?.Invoke();
            GameObject coinVFXInstance = Instantiate(coinVFX, transform.position, Quaternion.identity);
            Destroy(coinVFXInstance, 1f);
            Destroy(gameObject);
        }
    }
    
    // Keeps rotating in Y
    // private void FixedUpdate()
    // {
    //     transform.Rotate(0, 1, 0);
    // }
    
    
}

================
File: Assets/Elements/Coin/CoinText.cs
================
using System;
using TMPro;
using UnityEngine;

public class CoinText : MonoBehaviour
{
    private TextMeshProUGUI textMesh;
    private int coinCount;
    public bool isGems = false;

    private const string COIN_PREF_KEY = "CoinCount"; // Key for PlayerPrefs

    void Start()
    {
        textMesh = GetComponent<TextMeshProUGUI>();
        if (isGems)
        {
            return;
        }

        // Load coin count from PlayerPrefs
        coinCount = PlayerPrefs.GetInt(COIN_PREF_KEY, 0);
        
        textMesh.text = coinCount.ToString();

        Coin.OnCoinCollected += AddCoin;
    }

    public void AddCoin()
    {
        
        if (isGems)
        {
            return;
        }
        coinCount++;
        textMesh.text = coinCount.ToString();

        // Save updated coin count to PlayerPrefs
        PlayerPrefs.SetInt(COIN_PREF_KEY, coinCount);
        PlayerPrefs.Save(); // Ensures the data is written to disk
    }

    private void OnDestroy()
    {
        Coin.OnCoinCollected -= AddCoin;
    }
}

================
File: Assets/Elements/Ground/Ground.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Ground : MonoBehaviour
{
    public GameObject startAttachPoint, endAttachPoint, track;

    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

================
File: Assets/Elements/Ground/SpawnObstacles.cs
================
using UnityEngine;
using System.Collections.Generic;

public class SpawnObstacles : MonoBehaviour
{
    [Header("Track Generation")]
    [SerializeField] private BiomeModule[] biomeModules;
    [SerializeField] private int initialTrackCount = 5;
    [SerializeField] private float spawnTriggerDistance = 20f;
    [SerializeField] private float despawnDistance = -10f;
    
    [Header("Obstacle Settings")]
    [SerializeField] private GameObject[] obstacles;
    [SerializeField] private float minObstacleSpacing = 5f;
    [SerializeField] private float maxObstacleSpacing = 15f;
    [SerializeField] private float obstacleSpawnProbability = 0.7f;

    private List<BiomeModule> activeModules = new List<BiomeModule>();
    private Transform playerTransform;
    private Vector3 lastSpawnPosition;
    private float trackLength;

    private void Start()
    {
        if (biomeModules == null || biomeModules.Length == 0)
        {
            Debug.LogError("No biome modules assigned to track spawner!");
            return;
        }

        playerTransform = GameObject.FindGameObjectWithTag("Player").transform;
        if (!playerTransform)
        {
            Debug.LogError("Player not found! Make sure it's tagged as 'Player'");
            return;
        }

        // Initialize first track piece
        SpawnInitialTrack();
    }

    private void Update()
    {
        if (playerTransform == null) return;

        // Check if we need to spawn new track
        BiomeModule lastModule = activeModules[activeModules.Count - 1];
        if (Vector3.Distance(playerTransform.position, lastModule.ModuleEnd.transform.position) < spawnTriggerDistance)
        {
            SpawnNextTrackPiece();
        }

        // Check if we need to despawn old track
        if (activeModules.Count > 0)
        {
            BiomeModule firstModule = activeModules[0];
            if (firstModule.transform.position.x < despawnDistance)
            {
                DespawnTrackPiece(firstModule);
            }
        }
    }

    private void SpawnInitialTrack()
    {
        Vector3 spawnPos = transform.position;
        for (int i = 0; i < initialTrackCount; i++)
        {
            SpawnTrackPiece(spawnPos);
        }
    }

    private void SpawnNextTrackPiece()
    {
        BiomeModule lastModule = activeModules[activeModules.Count - 1];
        Vector3 spawnPos = lastModule.ModuleEnd.transform.position;
        SpawnTrackPiece(spawnPos);
    }

    private void SpawnTrackPiece(Vector3 position)
    {
        BiomeModule prefab = biomeModules[Random.Range(0, biomeModules.Length)];
        BiomeModule newModule = Instantiate(prefab, position, Quaternion.identity);
        activeModules.Add(newModule);

        // Spawn obstacles on the new track piece
        SpawnObstaclesOnModule(newModule);
    }

    private void SpawnObstaclesOnModule(BiomeModule module)
    {
        if (obstacles == null || obstacles.Length == 0) return;

        float currentPos = 0f;
        float moduleLength = Vector3.Distance(module.transform.position, module.ModuleEnd.transform.position);

        while (currentPos < moduleLength)
        {
            if (Random.value < obstacleSpawnProbability)
            {
                GameObject obstacle = obstacles[Random.Range(0, obstacles.Length)];
                Vector3 spawnPos = Vector3.Lerp(module.transform.position, module.ModuleEnd.transform.position, currentPos / moduleLength);
                Instantiate(obstacle, spawnPos, Quaternion.identity, module.transform);
            }
            currentPos += Random.Range(minObstacleSpacing, maxObstacleSpacing);
        }
    }

    private void DespawnTrackPiece(BiomeModule module)
    {
        activeModules.Remove(module);
        Destroy(module.gameObject);
    }
}

================
File: Assets/Elements/LevelEnd/UnityInterstitialAd.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Advertisements;
public class UnityInterstitialAd : MonoBehaviour, IUnityAdsLoadListener, IUnityAdsShowListener
{
    [SerializeField] string _androidAdUnitId = "Interstitial_Android";
    [SerializeField] string _iOsAdUnitId = "Interstitial_iOS";
    string _adUnitId;

    public static UnityInterstitialAd Instace;
    void Awake()
    {
        // Get the Ad Unit ID for the current platform:
        _adUnitId = _androidAdUnitId;
    }

    void Start()
    {
        if(Instace == null)
        {
            Instace = this;
        }
        else
        {
            Destroy(this.gameObject);
        }
        //Load Ad
        LoadAd();

    }
    // Load content to the Ad Unit:
    public void LoadAd()
    {
        // IMPORTANT! Only load content AFTER initialization (in this example, initialization is handled in a different script).
        Debug.Log("Loading Ad: " + _adUnitId);
        Advertisement.Load(_adUnitId, this);
    }

    // Show the loaded content in the Ad Unit:
    public void ShowAd()
    {
        // Note that if the ad content wasn't previously loaded, this method will fail
        Debug.Log("Showing Ad: " + _adUnitId);
        Advertisement.Show(_adUnitId, this);
        Invoke("LoadAd", 5f);
        
    }

    // Implement Load Listener and Show Listener interface methods: 
    public void OnUnityAdsAdLoaded(string adUnitId)
    {
        // Optionally execute code if the Ad Unit successfully loads content.   
    }

    public void OnUnityAdsFailedToLoad(string _adUnitId, UnityAdsLoadError error, string message)
    {
        Debug.Log($"Error loading Ad Unit: {_adUnitId} - {error.ToString()} - {message}");
        // Optionally execute code if the Ad Unit fails to load, such as attempting to try again.
    }

    public void OnUnityAdsShowFailure(string _adUnitId, UnityAdsShowError error, string message)
    {
        Debug.Log($"Error showing Ad Unit {_adUnitId}: {error.ToString()} - {message}");
        // Optionally execute code if the Ad Unit fails to show, such as loading another ad.
    }

    public void OnUnityAdsShowStart(string _adUnitId) { }
    public void OnUnityAdsShowClick(string _adUnitId) { }
    public void OnUnityAdsShowComplete(string _adUnitId, UnityAdsShowCompletionState showCompletionState) { }
}

================
File: Assets/Elements/LevelEnd/UnityRewardedAd.cs
================
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Advertisements;
public class UnityRewardedAd : MonoBehaviour, IUnityAdsLoadListener, IUnityAdsShowListener
{
    
    [SerializeField] string _androidAdUnitId = "Rewarded_Android";
    string _adUnitId = null; // This will remain null for unsupported platforms
    public static UnityRewardedAd Instace;
    void Awake()
    {
        // Get the Ad Unit ID for the current platform:

#if UNITY_ANDROID
        _adUnitId = _androidAdUnitId;
#endif
        //Load Ad
        LoadAd();   
    }
    void Start()
    {
        if (Instace == null)
        {
            Instace = this;
        }
        else
        {
            Destroy(this.gameObject);
        }
    }

    // Call this public method when you want to get an ad ready to show.
    public void LoadAd()
    {
        // IMPORTANT! Only load content AFTER initialization (in this example, initialization is handled in a different script).
        Debug.Log("Loading Ad: " + _adUnitId);
        Advertisement.Load(_adUnitId, this);
    }

    // If the ad successfully loads, add a listener to the button and enable it:
    public void OnUnityAdsAdLoaded(string adUnitId)
    {
        Debug.Log("Ad Loaded: " + adUnitId);

        if (adUnitId.Equals(_adUnitId))
        {
            
        }
    }

    // Implement a method to execute when the user clicks the button:
    public void ShowAd()
    {
        
        // Then show the ad:
        Advertisement.Show(_adUnitId, this);
        //Load Ad after ad is shown
        Invoke("LoadAd", 5f);
    }

    // Implement the Show Listener's OnUnityAdsShowComplete callback method to determine if the user gets a reward:
    public void OnUnityAdsShowComplete(string adUnitId, UnityAdsShowCompletionState showCompletionState)
    {
        if (adUnitId.Equals(_adUnitId) && showCompletionState.Equals(UnityAdsShowCompletionState.COMPLETED))
        {
            Debug.Log("Unity Ads Rewarded Ad Completed");
            // Grant a reward.
        }
    }

    // Implement Load and Show Listener error callbacks:
    public void OnUnityAdsFailedToLoad(string adUnitId, UnityAdsLoadError error, string message)
    {
        Debug.Log($"Error loading Ad Unit {adUnitId}: {error.ToString()} - {message}");
        // Use the error details to determine whether to try to load another ad.
    }

    public void OnUnityAdsShowFailure(string adUnitId, UnityAdsShowError error, string message)
    {
        Debug.Log($"Error showing Ad Unit {adUnitId}: {error.ToString()} - {message}");
        // Use the error details to determine whether to try to load another ad.
    }

    public void OnUnityAdsShowStart(string adUnitId) { }
    public void OnUnityAdsShowClick(string adUnitId) { }

   
}

================
File: Assets/Elements/UI/UITimer.cs
================
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;  // Necessário para trabalhar com UI Image e UI Text

public class UITimer : MonoBehaviour
{
    [SerializeField] private Image radialTimerImage;  // Referência para a imagem do timer (UI Image)
    [SerializeField] private TextMeshProUGUI timerText;  // Referência para o texto que exibe o tempo restante
    [SerializeField] private float timerDuration = 5f;  // A duração total do timer (5 segundos)
    private float timer;  // Contador do tempo

    private void Start()
    {
        // Inicializa o timer
        if (radialTimerImage != null)
        {
            radialTimerImage.fillAmount = 1f;  // Começa com o timer cheio
        }
        if (timerText != null)
        {
            timerText.text = timer.ToString("F0");  // Mostra o tempo restante no formato de 1 casa decimal
        }
        timer = timerDuration;  // Define o tempo total do timer
    }

    private void Update()
    {
        // Subtrai o tempo no timer a cada frame
        if (timer > 0)
        {
            timer -= Time.deltaTime;  // Diminui o tempo
            float fillAmount = Mathf.Clamp01(timer / timerDuration);  // Calcula o preenchimento proporcional
            radialTimerImage.fillAmount = fillAmount;  // Atualiza o preenchimento da imagem

            // Atualiza o texto com o tempo restante (com 1 casa decimal)
            if (timerText != null)
            {
                timerText.text = timer.ToString("F0");  // Mostra o tempo restante no formato de 1 casa decimal
            }
        }
        else
        {
            // Timer terminou, chame o evento ou lógica que você deseja aqui
            // ShowRevivePanel();
            OnTimerEnd?.Invoke();
        }
    }

    public UnityEvent OnTimerEnd;

    // Função que reinicia o timer, se necessário
    public void ResetTimer()
    {
        timer = timerDuration;  // Restaura o tempo total
        radialTimerImage.fillAmount = 0.3f;  // Restaura o preenchimento do radial timer

        if (timerText != null)
        {
            timerText.text = timer.ToString("F0");  // Mostra o tempo restante no formato de 1 casa decimal
        }
    }

    // Função para exibir o painel de reviver (ou qualquer lógica que você precise)
    private void ShowRevivePanel()
    {
        // Ative o painel ou faça qualquer outra ação necessária quando o timer terminar
        Debug.Log("Timer Finalizado!");
        // Aqui você pode ativar um painel de UI de reviver, por exemplo:
        // revivePanel.SetActive(true);
    }
}

================
File: Assets/Elements/SpeedManager.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SpeedManager : MonoBehaviour
{
    public AnimationCurve speedCurve;
    public static float globalSpeedMultiplier = 1f, startingSpeed = 1f, relativeSpeed = 1f;
    
    void Start(){
        startingSpeed = speedCurve.Evaluate(0);
        
    }
    

    void Update(){
        globalSpeedMultiplier = speedCurve.Evaluate(Time.time);
        
        relativeSpeed = globalSpeedMultiplier / startingSpeed;
    }
}

================
File: Assets/Elements/Ground/Spike/Spike.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Spike : MonoBehaviour
{
    public GameObject spikeVFX;
    public static event Action OnSpikeHit;

    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Character")
        {
            OnSpikeHit?.Invoke();

            other.GetComponent<SmurfCatMovement>().Die();
            
        }
    }
    
}

================
File: Assets/Elements/LevelEnd/AdsInitializer.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Advertisements;
public class AdsInitializer : MonoBehaviour, IUnityAdsInitializationListener
{
    [SerializeField] string _androidGameId;
    [SerializeField] string _iOSGameId;
    [SerializeField] bool _testMode = true;
    private string _gameId;

    void Awake()
    {
        InitializeAds();
    
    }

    public void InitializeAds()
    {
#if UNITY_IOS
            _gameId = _iOSGameId;
#elif UNITY_ANDROID
        _gameId = _androidGameId;
#elif UNITY_EDITOR
            _gameId = _androidGameId; //Only for testing the functionality in the Editor
#endif
        
        
        
        if (!Advertisement.isInitialized && Advertisement.isSupported)
        {
            Advertisement.Initialize(_gameId, _testMode, this);
        
        //     // Configure COPPA compliance for child-directed treatment
        //     MetaData metaData = new MetaData("gdpr");
        //     metaData.Set("gdpr.consent", "false"); // No personalized ads for children
        //     Advertisement.SetMetaData(metaData);
        //
        //     MetaData childDirectedMetaData = new MetaData("user");
        //     childDirectedMetaData.Set("user.nonbehavioral", "true"); // Treat users as non-behavioral
        //     Advertisement.SetMetaData(childDirectedMetaData);
        //     
        }
    }


    public void OnInitializationComplete()
    {
        Debug.Log("Unity Ads initialization complete.");
    }

    public void OnInitializationFailed(UnityAdsInitializationError error, string message)
    {
        Debug.Log($"Unity Ads Initialization Failed: {error.ToString()} - {message}");
    }
}

================
File: Assets/Elements/LevelEnd/UnityBannerAd.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Advertisements;


public class UnityBannerAd : MonoBehaviour
{
    

    [SerializeField] BannerPosition _bannerPosition = BannerPosition.BOTTOM_CENTER;

    [SerializeField] string _androidAdUnitId = "Banner_Android";
    string _adUnitId = "Banner_Android"; // This will remain null for unsupported platforms.

    void Start()
    {
        // Get the Ad Unit ID for the current platform:
#if UNITY_IOS
        _adUnitId = _iOSAdUnitId;
#elif UNITY_ANDROID
        _adUnitId = _androidAdUnitId;
#endif

      

        // Set the banner position:
        Advertisement.Banner.SetPosition(_bannerPosition);

       //Load Banner Ad with 1 sec delay
        Invoke("LoadBanner",1f);
        
    }
   

    // Implement a method to call when the Load Banner button is clicked:
    public void LoadBanner()
    {
        // Set up options to notify the SDK of load events:
        BannerLoadOptions options = new BannerLoadOptions
        {
            loadCallback = OnBannerLoaded,
            errorCallback = OnBannerError
        };

        // Load the Ad Unit with banner content:
        Advertisement.Banner.Load(_adUnitId, options);
    }

    // Implement code to execute when the loadCallback event triggers:
    void OnBannerLoaded()
    {
        Debug.Log("Banner loaded");
        ShowBannerAd();  
    }

    // Implement code to execute when the load errorCallback event triggers:
    void OnBannerError(string message)
    {
        Debug.Log($"Banner Error: {message}");
        // Optionally execute additional code, such as attempting to load another ad.
    }

    // Implement a method to call when the Show Banner button is clicked:
    void ShowBannerAd()
    {
        // Set up options to notify the SDK of show events:
        BannerOptions options = new BannerOptions
        {
            clickCallback = OnBannerClicked,
            hideCallback = OnBannerHidden,
            showCallback = OnBannerShown
        };

        // Show the loaded Banner Ad Unit:
        Advertisement.Banner.Show(_adUnitId, options);
    }

    // Implement a method to call when the Hide Banner button is clicked:
    void HideBannerAd()  
    {
        // Hide the banner:
        Advertisement.Banner.Hide();
    }

    void OnBannerClicked() { }
    void OnBannerShown() { }
    void OnBannerHidden() { }

   
}

================
File: Assets/Elements/Other/FpsManager.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FpsManager : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        Application.targetFrameRate = 60;
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

================
File: Assets/Elements/MoveForward.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MoveForward : MonoBehaviour
{
    
    private float speed = 10f;

    void Update()
    {
        speed = -SpeedManager.globalSpeedMultiplier;
        transform.position = new Vector3(transform.position.x, transform.position.y, transform.position.z + speed * Time.deltaTime);
    }
}

================
File: Assets/Elements/TutorialItem.cs
================
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;

public partial class TutorialItem : MonoBehaviour
{
    [SerializeField]float timeToDestroy = 5.0f;  // Total time to destroy in seconds

    void Start()
    {
        StartCoroutine(DestroyAfterTime());
        
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
    
    IEnumerator DestroyAfterTime()
    {
        yield return new WaitForSeconds(timeToDestroy);
        transform.DOScale(Vector3.zero, 1f).SetEase(Ease.InBack).OnComplete(() => Destroy(gameObject));
        
    }
}

================
File: Assets/Elements/LevelEnd/LevelEnd.cs
================
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;
using TMPro;
using UnityEngine;

public class LevelEnd : MonoBehaviour
{
    [SerializeField] private GameObject levelEndOverlay;
    [SerializeField] private CanvasGroup canvasGroup;
    [SerializeField] private TextMeshProUGUI levelEndText;
    public AudioManager audioManager;

    private readonly List<string> phrases = new List<string>
    {
        "Exploration Failed!",
        "Rest in orbit.",
        "Gravity won this time.",
        "Calling for backup...",
        "What an epic fall!",
        "Game over... but the universe remembers you.",
        "Out of fuel for another try?",
        "Ran too far, flew too little.",
        "The planet thanks you for your sacrifice.",
        "Fell with style!",
        "Explorer down in action.",
        "Luck left you... for now.",
        "Back to square one.",
        "Planetary collision detected.",
        "Gotta fly to survive.",
        "Exotic attempt failed.",
        "Nothing like an otherworldly fall!",
        "The stars didn’t save you this time.",
        "RIP - Rest In Planetary dust",
        "If the platforms could talk...",
        "A leap of courage... almost!",
        "Intergalactic fate: failure.",
        "Gravity did its job.",
        "Rest in stardust.",
        "You hit the zero point!",
        "Your last flight was legendary.",
        "Ran out of fuel... or luck.",
        "The beauty of the cosmos... and the fall!",
        "Nothing like gravity to teach you a lesson.",
        "Another chance to challenge the planets?"
    };

    public void Start()
    {
        audioManager.StopFallingAudio();
        audioManager.PauseMusic();
        EndLevel();
    }

    public void EndLevel()
    {
        levelEndOverlay.SetActive(true);

        // Escolhe uma frase aleatória e aplica ao texto
        int randomIndex = Random.Range(0, phrases.Count);
        levelEndText.text = phrases[randomIndex];

        // Animação de entrada para o overlay
        canvasGroup.alpha = 0;
        canvasGroup.DOFade(1, 1f);

        levelEndOverlay.transform.localScale = Vector3.zero;
        levelEndOverlay.transform.DOScale(1, 1f).SetEase(Ease.OutBack);

        // Aplica animação em loop no texto
        AnimateTextLoop();
    }

    private void AnimateTextLoop()
    {
        // Define a posição inicial e a escala do texto
        levelEndText.transform.localScale = Vector3.one * 0.9f;
        levelEndText.transform.localPosition = new Vector3(levelEndText.transform.localPosition.x, levelEndText.transform.localPosition.y - 10, levelEndText.transform.localPosition.z);

        // Anima o texto com efeito de "pulse" e movimento vertical
        levelEndText.transform.DOScale(1.05f, 0.8f)
            .SetEase(Ease.InOutQuad)
            .SetLoops(-1, LoopType.Yoyo); // Loop infinito para efeito de "pulse"

        levelEndText.transform.DOLocalMoveY(levelEndText.transform.localPosition.y + 10, 0.8f)
            .SetEase(Ease.InOutQuad)
            .SetLoops(-1, LoopType.Yoyo); // Loop infinito para efeito de movimento suave
    }
}

================
File: Assets/Elements/UI/Scripts/PauseMenu.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using TMPro;
public class PauseMenu : MonoBehaviour
{

    [SerializeField] private Button SFXButton;
    [SerializeField] private TextMeshProUGUI SFXText;
    [SerializeField] private AudioManager audioManager;
    public static bool isPaused = false;
    private bool sfxOn = true;

    void Awake()
    {
    }
    public void PauseGame()
    {
        Time.timeScale = 0;
        audioManager.PauseFallingAudio();
        audioManager.StopSFX();
        isPaused = true;
    }
    public void UnpauseGame()
    {
        Time.timeScale = 1;
        isPaused = false;
    }
    public void Home()
    {
        UnpauseGame();
        SceneManager.LoadSceneAsync(0);
    }

    public void Restart()
    {
        UnpauseGame();
        RestartScene();
    }
    
    public static void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }

    public void TurnSFX()
    {
        
        sfxOn = !sfxOn;
        PlayerPrefs.SetInt("SFX", sfxOn ? 1 : 0);
        if (sfxOn)
        {
            TurnOnSound();
        }
        else
        {
            TurnOffSound();
        }
    }
    public void TurnOnSound()
    {
        SFXButton.GetComponent<Image>().color = Color.white;
        SFXText.text = "ON";
        audioManager.UnmuteMaster();
    }
    public void TurnOffSound()
    {
        SFXButton.GetComponent<Image>().color = Color.gray;
        SFXText.text = "OFF";
        audioManager.MuteMaster();
    }
    public void Initialize()
    {
        
        sfxOn = PlayerPrefs.GetInt("SFX", 1) == 1;
        if (sfxOn)
        {
            TurnOnSound();
        }
        else
        {
            TurnOffSound();
        }

        audioManager = GameObject.FindWithTag("Audio").GetComponent<AudioManager>();
    }

}

================
File: Assets/Elements/Camera/CameraController.cs
================
using System.Collections.Generic;
using UnityEngine;
using Cinemachine;
using DG.Tweening;

public class CameraController : MonoBehaviour
{
    [SerializeField] private CinemachineVirtualCamera virtualCamera;
    private Vector3 groundedOffset = new Vector3(0, 5, -10);
    [SerializeField] private Vector3 airborneOffset = new Vector3(0, 8, -12);
    [SerializeField] private float transitionSpeed = 1f;
    [SerializeField] private List<CinemachineVirtualCameraBase> virtualCameras;
    [SerializeField] private GameObject virtualCameraFollow;
    [SerializeField] private GameObject virtualCameraLookAt;
    [SerializeField] private CinemachineImpulseSource impulseSource;
    [SerializeField]private CinemachineTransposer transposer;
    private CinemachineBasicMultiChannelPerlin perlinNoise;
    private bool isAirborne = false;
    
    // Deslocamento da câmera para cima e para trás durante a morte
    [SerializeField] private float deathHeightOffset = 10f; // Deslocamento da câmera para cima
    [SerializeField] private float deathBackOffset = 5f; // Deslocamento para trás no eixo Z
    
    [Header("Camera Shake Settings")]
    [SerializeField] private float minShakeDuration = 0.2f;  // Duração mínima do shake
    [SerializeField] private float maxShakeDuration = 0.5f;  // Duração máxima do shake
    [SerializeField] private float minShakeStrength = 1f;     // Intensidade mínima do shake
    [SerializeField] private float maxShakeStrength = 3f;     // Intensidade máxima do shake
    
    [SerializeField] private float bumpStrength = 1f;

    private bool isDead = false;  // Flag para saber se o personagem está morto

    private void Start()
    {
        perlinNoise = virtualCamera.GetCinemachineComponent<CinemachineBasicMultiChannelPerlin>();
        transposer = virtualCamera.GetCinemachineComponent<CinemachineTransposer>();
        impulseSource = virtualCamera.GetComponent<CinemachineImpulseSource>(); 
        virtualCameraLookAt = transposer.LookAtTarget.gameObject;
        virtualCameraFollow = transposer.FollowTarget.gameObject;

        groundedOffset = transposer.m_FollowOffset;
        // airborneOffset = new Vector3(groundedOffset.x + airborneOffset.x, groundedOffset.y + airborneOffset.y, groundedOffset.z + airborneOffset.z);
        if (virtualCamera == null)
        {
            Debug.LogError("Cinemachine Virtual Camera is not assigned.");
            return;
        }

        transposer.m_FollowOffset = groundedOffset; // Set initial offset
    }

    void OnEnable()
    {
        SmurfCatMovement.onGroundImpact += CameraBump;
        SmurfCatMovement.onGroundImpact += StopShake;
        SmurfCatMovement.onHighFallSpeed += StartShake;

    }

    void OnDisable()
    {
        SmurfCatMovement.onGroundImpact -= CameraBump;
        SmurfCatMovement.onGroundImpact -= StopShake;
        SmurfCatMovement.onHighFallSpeed -= StartShake;
    }

    public void SetAirborne(bool airborne)
    {
        isAirborne = airborne;
        // virtualCameras[1].Priority = isAirborne ? 11 : 0;
    }

    // Função chamada quando o personagem morre
    public void OnPlayerDeath()
    {
        isDead = true;

        // Desativa temporariamente o Follow e o LookAt da câmera
        virtualCamera.Follow = null;
        virtualCamera.LookAt = null;  // Remove o LookAt do jogador

        // Calcula a nova posição da câmera (deslocando para cima a posição atual e para trás no eixo Z)
        Vector3 newCameraPosition = virtualCamera.transform.position + new Vector3(0, deathHeightOffset, -deathBackOffset);

        // Transição da câmera para a nova posição calculada
        virtualCamera.transform.DOMove(newCameraPosition, 0.5f).SetEase(Ease.InOutSine); // Acelerando a transição com um valor de tempo menor

        // Ajustando a rotação para olhar para baixo (verticalmente)
        virtualCamera.transform.DORotate(new Vector3(90, 0, 0), 0.5f)
            .SetEase(Ease.InSine); // Rotaciona para olhar para baixo
        // .OnComplete(() => RestoreCameraFollow());  // Quando a transição terminar, restaura o Follow.
    }

    // Função para restaurar a posição e o Follow após a transição
    private void RestoreCameraFollow()
    {
        // Reconecta o Follow ao jogador
        virtualCamera.Follow = virtualCameraFollow.transform;
        virtualCamera.LookAt = virtualCameraLookAt.transform;
        

        // Transição suave de volta para o offset normal
        transposer.m_FollowOffset = groundedOffset;

        // Restaura a rotação normal da câmera
        virtualCamera.transform.DORotate(Vector3.zero, 0.5f).SetEase(Ease.InOutSine); // Restaura a rotação para normal (olhando para o jogador)
    }

    // Função para reviver o personagem e restaurar a posição da câmera
    public void OnRevive()
    {
        RestoreCameraFollow();
        isDead = false;
        // Transição da câmera de volta para a posição normal
        virtualCamera.transform.DOMove(groundedOffset, 0.5f).SetEase(Ease.InOutSine); // Pode ajustar para o valor de offset desejado
        virtualCamera.transform.DORotate(Vector3.zero, 0.5f).SetEase(Ease.InOutSine); // Restaura a rotação para normal (olhando para o jogador)
    }
    
    public void CameraBump()
    {
        // Gera a duração e intensidade aleatórias dentro dos intervalos definidos
        float shakeDuration = Random.Range(minShakeDuration, maxShakeDuration);
        bumpStrength = Random.Range(bumpStrength * 0.7f, bumpStrength * 1.3f);

        // Aplica o impacto na direção 'up' da câmera com intensidade e duração aleatórias
        impulseSource.GenerateImpulse(Vector3.up * bumpStrength);

        // Pode-se incluir alguma lógica para limitar o tempo ou manipular o efeito de fade out, por exemplo
    }
    public void StartShake()
    {
        // Ativa o Perlin Noise para o shake
        perlinNoise.m_FrequencyGain = 1.5f;
        perlinNoise.m_AmplitudeGain = 1.5f;
    }

    // Para o shake, restaurando os valores
    private void StopShake()
    {
        perlinNoise.m_AmplitudeGain = 0f;  // Desativa o tremor
        perlinNoise.m_FrequencyGain = 0f;
    }

    private void Update()
    {
        if (isDead) return; // Se o personagem está morto, não faz sentido mover a câmera com base na posição do jogador

        if (!transposer) return;

        // Escolhe o target offset baseado se o personagem está no ar ou no chão
        Vector3 targetOffset = isAirborne ? airborneOffset : groundedOffset;

        // Interpola suavemente o offset atual para o offset alvo
        transposer.m_FollowOffset = Vector3.Lerp(
            transposer.m_FollowOffset,
            targetOffset,
            Time.deltaTime * transitionSpeed 
        );
    }
}

================
File: Assets/Elements/Audio/AudioManager.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using UnityEngine;
using UnityEngine.Audio;
using Random = UnityEngine.Random;

public class AudioManager : MonoBehaviour
{
    [SerializeField] private AudioMixer audioMixer;
    [Header("--- Audio Manager ---")]
    [SerializeField] private AudioSource musicSource;
    [SerializeField] public AudioSource SFXSource;
    [SerializeField] private AudioSource fallingSource;
    [SerializeField] private float minPitch = 0.8f; // Min pitch range
    [SerializeField] private float maxPitch = 1.2f; // Max pitch range

    [Header("--- Clips ---")]
    [SerializeField] public AudioClip[] sfx;
    [SerializeField] public AudioClip[] sondTrack;
    [SerializeField] private List<AudioClip> impactSounds; // List of impact sounds

    [SerializeField] private PauseMenu pauseMenu;
    bool alreadyPlayed = false;
    bool deathMarch = false;

    private void Awake()
    {
        if (!alreadyPlayed)
        {
            musicSource.Play();
            alreadyPlayed = true;
        }
    }
    void Start()
    {
        pauseMenu.Initialize();
        Coin.OnCoinCollected += PlayCoinAudio;
    }

    IEnumerator Chronos()
    {
        yield return new WaitForSeconds(2);
        ResumeSong();
    }

    public void PlaySFX(AudioClip clip)
    {
        if (clip == null) return;

        // Apply random pitch
        SFXSource.pitch = Random.Range(minPitch, maxPitch);
        SFXSource.PlayOneShot(clip);
    }

    public void MuteMaster()
    {
        audioMixer.SetFloat("MasterVolume", -80);
    }

    public void UnmuteMaster()
    {
        audioMixer.SetFloat("MasterVolume", 0);
    }

    public void PlayCoinAudio()
    {
        PlaySFX(sfx[0]);
    }

    public void PlayFallingAudio ()
    {
        // Check if its not playing, then change the pit and Play()
        if (!fallingSource.isPlaying)
        {
            fallingSource.pitch = Random.Range(minPitch, maxPitch);
            fallingSource.Play();
        }

    }

    public void StopFallingAudio()
    {
        if (fallingSource != null && fallingSource.isPlaying)
        {
            fallingSource.Stop();
        }
    }

    public void PauseFallingAudio()
    {
        if (fallingSource != null && fallingSource.isPlaying)
        {
            fallingSource.Pause();
        }
    }

    // Play a random impact sound from the list
    public void PlayRandomImpactSound()
    {
        if (impactSounds.Count > 0)
        {
            // Select a random clip from the list
            AudioClip randomImpactClip = impactSounds[UnityEngine.Random.Range(0, impactSounds.Count)];
            SFXSource.PlayOneShot(randomImpactClip);
        }
        else
        {
            Debug.LogWarning("No impact sounds are set in the impactSounds list.");
        }
    }
    
    public void PlayJumpSound()
    {
        SFXSource.pitch = Random.Range(minPitch, maxPitch);

        PlaySFX(sfx[1]);
    }

    public void PlayDeathSound()
    {
        musicSource.Pause();
        if (!deathMarch)
        {
            PlaySFX(sfx[2]);
            deathMarch = true;
        }
        else
            return;
    }

    public void PauseMusic()
    {
        musicSource.Pause();
    }

    public void PlayMusic()
    {
        if (!musicSource.isPlaying)
            musicSource.Play();

    }

    public void PlayReviveSound()
    {
        PlaySFX(sfx[3]);
        StartCoroutine(Chronos());
        deathMarch = false;
    }
    public void ResumeSong()
    {
        if (!musicSource.isPlaying)
            musicSource.Play();
    }
    private void OnDestroy()
    {
        Coin.OnCoinCollected -= PlayCoinAudio;
    }

    public void StopSFX()
    {
        SFXSource.Stop();
    }
}

================
File: Assets/Elements/Juice/Juice.cs
================
using UnityEngine;
using DG.Tweening;
using System.Collections;
using TMPro;

public class Juice : MonoBehaviour
{
    [Header("Scale Animation Settings")]
    public bool animateScale = false;
    public float scaleMultiplier = 1.5f;       // Scale multiplier for the initial effect
    public float scaleDuration = 0.5f;
    public Ease scaleEase = Ease.OutBack;
    public bool shouldAnimateWhilePaused = true;     // Continue animation even when Time.timeScale = 0
    private Tween activationTween; // Armazena a referência ao tween de ativação
    private Vector3 baseScale;                 // Stores the original scale of the object

    [Header("Deactivation/Destruction Animation Settings")]
    public bool animateOnDeactivateOrDestroy = true;
    public float deactivationScaleDuration = 0.5f; // Duration of the deactivation scale animation
    public Ease deactivationEase = Ease.InBack;
    public float fadeOutDuration = 0.5f;          // Duration for fade-out effect

    [Header("Rotation Animation Settings")]
    public bool animateRotation = false;
    public Vector3 rotationAxis = new Vector3(0, 360, 0); // Rotates around the Y-axis by default
    public float rotationDuration = 2f;

    [Header("Vertical Bounce Animation Settings")]
    public bool animateVerticalBounce = false;
    public float bounceHeight = 0.5f;          // Height of the bounce
    public float bounceDuration = 1f;
    public Ease bounceEase = Ease.InOutSine;
    
    [Header("Horizontal Bounce Animation Settings")]
    public bool animateHorizontalBounce = false;
    public float horizontalBounceDistance = 1f;  // How far it moves on X axis
    public float horizontalBounceDuration = 1f;
    public Ease horizontalBounceEase = Ease.InOutSine;

    [Header("Rainbow Mode Settings")]
    public bool rainbowMode = false;           // Activates rainbow color cycling mode
    public float rainbowSpeed = 5f;            // Speed of color transition

    private Material material;
    private MaterialPropertyBlock propBlock;
    private Renderer objectRenderer;

    private void Awake()
    {
        baseScale = transform.localScale; // Store the original scale
        objectRenderer = GetComponent<Renderer>();

        if (objectRenderer != null)
        {
            material = objectRenderer.material;
            propBlock = new MaterialPropertyBlock();
        }
    }

    private void OnEnable()
    {
        PlayActivationAnimation();

    }

    private void Update()
    {
        if (rainbowMode && objectRenderer != null)
        {
            ApplyRainbowEffect();
        }
    }

    public void PlayActivationAnimation()
    {

        // Só aplica a animação se o jogo não estiver pausado
        if (Time.timeScale == 0)
        {
            // Se o jogo estiver pausado, apenas assegura que o objeto está ativo, mas sem alterar a escala.
            gameObject.SetActive(true);
            return;
        }

        gameObject.SetActive(true);

        if (animateRotation)
            PlayRotationAnimation();

        if (animateVerticalBounce)
            PlayBounceAnimation();
        
        if (animateHorizontalBounce)
            PlayBounceAnimation();

        if (!animateScale) return;

        // Salve a escala original antes de começar a animação
        Vector3 originalScale = transform.localScale;

        // Se o jogo não está pausado, comece com a escala zero para o efeito de "pop-in"
        transform.localScale = Vector3.zero;

        // Animação suave para aumentar a escala até o tamanho desejado
        activationTween = transform.DOScale(baseScale * scaleMultiplier, scaleDuration)
            .SetUpdate(UpdateType.Normal, true)
            .SetEase(scaleEase);
    }




    public void PlayDeactivationOrDestroyAnimation(System.Action onComplete)
    {
        if (!animateOnDeactivateOrDestroy)
        {
            onComplete?.Invoke();
            return;
        }

        // Scale down animation
        transform.DOScale(Vector3.zero, deactivationScaleDuration)
            .SetEase(deactivationEase)
            .SetUpdate(shouldAnimateWhilePaused) // Ensures animation runs even when timeScale = 0
            .OnComplete(() =>
            {
                onComplete?.Invoke();
                gameObject.SetActive(false);
            });

        // Optional: Fade out if material allows
        if (objectRenderer != null)
        {
            FadeOutEffect();
        }
    }

    private void FadeOutEffect()
    {
        if (material == null || !material.HasProperty("_Color")) return;

        Color startColor = material.color;
        Color endColor = startColor;
        endColor.a = 0; // Fade to transparent

        material.DOColor(endColor, fadeOutDuration)
            .SetUpdate(shouldAnimateWhilePaused) // Ensures fade-out runs even when timeScale = 0
            .OnComplete(() =>
            {
                material.color = startColor; // Reset color for next activation
            });
    }

    private void PlayRotationAnimation()
    {
        transform.DORotate(rotationAxis, rotationDuration, RotateMode.LocalAxisAdd)
            .SetEase(Ease.Linear)
            .SetLoops(-1, LoopType.Incremental)
            .SetUpdate(UpdateType.Normal, true); // Ensures animation runs even when timeScale = 0
    }

    private void PlayBounceAnimation()
    {
        // Vertical Bounce
        if (animateVerticalBounce)
        {
            float startY = transform.position.y;
            transform.DOMoveY(startY + bounceHeight, bounceDuration)
                .SetEase(bounceEase)
                .SetLoops(-1, LoopType.Yoyo)
                .SetUpdate(UpdateType.Normal, true);
        }

        // Horizontal Bounce (opcional)
        if (animateHorizontalBounce)
        {
            float startX = transform.position.x;
            // Cria uma sequência para movimentar de forma simétrica: direita -> esquerda -> centro
            Sequence horizontalSequence = DOTween.Sequence();
            horizontalSequence.Append(transform.DOMoveX(startX + horizontalBounceDistance, horizontalBounceDuration / 2)
                .SetEase(horizontalBounceEase));
            horizontalSequence.Append(transform.DOMoveX(startX - horizontalBounceDistance, horizontalBounceDuration)
                .SetEase(horizontalBounceEase));
            horizontalSequence.Append(transform.DOMoveX(startX, horizontalBounceDuration / 2)
                .SetEase(horizontalBounceEase));
            horizontalSequence.SetLoops(-1)
                .SetUpdate(UpdateType.Normal, true);
        }
    }

    private void ApplyRainbowEffect()
    {
        float hue = Mathf.Repeat(Time.time * rainbowSpeed, 1);
        Color rainbowColor = Color.HSVToRGB(hue, 1, 1);

        objectRenderer.GetPropertyBlock(propBlock);
        propBlock.SetColor("_Color", rainbowColor);
        objectRenderer.SetPropertyBlock(propBlock);
    }

    public void Deactivate(System.Action onComplete = null) 
    {
        
        if (activationTween != null && activationTween.IsActive())
        {
            activationTween.Kill(); // Cancela a animação de ativação
            activationTween = null; // Reseta a variável
        }
        
        PlayDeactivationOrDestroyAnimation(() =>
        {
            onComplete?.Invoke(); 
        });
        return;
    }

    public void DestroyWithAnimation()
    {
        PlayDeactivationOrDestroyAnimation(() => Destroy(gameObject));
    }
}

================
File: Assets/Elements/Generator/Generator.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;
using TMPro;
using UnityEngine;
using Random = UnityEngine.Random;

[System.Serializable]
public class BiomeData
{
    public string biomeName; // Nome do Bioma (apenas para referência)
    public Color biomeColor;  // Cor característica do texto
    public GameObject biomeParticle;
    public Material biomeSkybox; // Skybox característico do bioma
    public int tracksBeforeChange = 10; // Número de pistas antes de mudar para o próximo bioma
    public List<GameObject> tracks; // Lista de pistas para o bioma
}

[System.Serializable]
public class TrackSpawnData
{
    public Vector3 position;
    public bool isCentralTrack;
}

public class Generator : MonoBehaviour
{
    [Header("Biomes Settings")] [SerializeField]
    private List<BiomeData> biomes; // Lista reordenável de biomas

    [SerializeField] private GameObject elementContainer;
    [SerializeField] private float timeToGenerate;
    [SerializeField] private float timeToDestroy;
    [SerializeField] private int tracksToChangeBiome = 10;
    [SerializeField] private TextMeshProUGUI biomeText;
    [SerializeField] private float delayBeforeBiomeChange = 2f;

    [Header("Position Variation Settings")] [SerializeField]
    private float minimumXPosition, maximumXPosition;

    [SerializeField] private float xVariationRange = 50f;
    [SerializeField] private float minYVariation = 30f;
    [SerializeField] private float maxYVariation = 150f;

    [SerializeField] private List<GameObject> modulesList;
    public GameObject currentModule;
    public Transform currentModuleEnd;

    private int currentBiomeIndex = 0; // Índice do bioma atual
    private List<GameObject> currentTracks; // Referência para as pistas do bioma atual
    private int tracksGenerated = 0; // Contador de pistas geradas
    private float cumulativeYOffset = 0f; // Acumula o deslocamento em Y
    private float initialZPosition = 0f;
    
    
    [Header("Parallel Tracks Settings")]
    [SerializeField] private int numberOfParallelTracks = 3;
    
    // Mantenha os campos existentes e adicione:
    [SerializeField] private List<GameObject> activeTracks = new List<GameObject>();
    private float latestEndPointZ;
    
    [Header("Track Generation Settings")]
    [SerializeField] private int parallelTracksCount = 3; // Número ímpar recomendado
    [SerializeField] private float trackSpacing = 50f;
    [SerializeField] private float safetyBuffer = 10f; // Margem antes do fim da pista

    private List<GameObject> activeBiomeModules = new List<GameObject>();
    private float furthestEndPointZ;

    public float FurthestEndPointZ => furthestEndPointZ;


    private void UpdateLatestEndPoint()
    {
        latestEndPointZ = float.MinValue;
        foreach (var track in activeTracks)
        {
            var endPoint = track.GetComponent<Ground>().endAttachPoint.transform.position.z;
            if (endPoint > latestEndPointZ)
            {
                latestEndPointZ = endPoint;
            }
        }
    }

    public float LatestEndPointZ => latestEndPointZ;

    [SerializeField] private GameObject lastElement, nextElement;

    private void OnEnable()
    {
        TutorialManager.onTutorialsFinished += ShowBiomeName;
    }
    
    private void OnDisable()
    {
        TutorialManager.onTutorialsFinished -= ShowBiomeName;
    }

    private void Start()
    {
        initialZPosition = transform.position.z;
        
        if (biomes.Count > 0)
        {
            currentTracks = biomes[currentBiomeIndex].tracks; // Define as pistas iniciais
            // ShowBiomeName();
        }
        else
        {
            Debug.LogError("Nenhum bioma configurado no Generator!");
        }
    }

    public void Generate()
    {
        UpdateBiome();
        GenerateParallelTracks();
        tracksGenerated++;
    }
    
    
    private void GenerateSingleTrack()
    {
        GameObject selectedTrack = SelectRandomGround();
        if (selectedTrack == null) return;

        nextElement = selectedTrack;
        Vector3 finalPosition = CalculateFinalPosition();
        GameObject newElement = InstantiateElement(selectedTrack, finalPosition);

        SetInitialScaleAndPosition(newElement, finalPosition);
        ApplyAnimations(newElement, finalPosition);
        ScheduleDestruction(newElement);

        transform.position = new Vector3(transform.position.x, transform.position.y, initialZPosition);
        lastElement = newElement;
    }
    
    private void GenerateParallelTracks()
    {
        GameObject selectedTrack = SelectRandomSingleTrack();
        if (selectedTrack == null) return;

        Vector3 centralPosition = CalculateTrackSpawnPosition();
        
        for (int i = 0; i < numberOfParallelTracks; i++)
        {
            float xOffset = (i - (numberOfParallelTracks - 1) / 2f) * trackSpacing;
            Vector3 spawnPosition = centralPosition + new Vector3(xOffset, 0, 0);
            
            GameObject newTrack = InstantiateTrack(selectedTrack, spawnPosition);
            activeTracks.Add(newTrack);
            
            UpdateLatestEndPoint();
            CleanupOldTracks();
        }
    }

    private Vector3 CalculateTrackSpawnPosition()
    {
        return new Vector3(
            Random.Range(minimumXPosition, maximumXPosition),
            transform.position.y - Random.Range(minYVariation, maxYVariation),
            latestEndPointZ
        );
    }
    
    private GameObject InstantiateTrack(GameObject prefab, Vector3 position)
    {
        GameObject newTrack = Instantiate(prefab, position, Quaternion.identity);
        newTrack.transform.parent = elementContainer.transform;
        InitializeTrack(newTrack);
        return newTrack;
    }

    private void InitializeTrack(GameObject track)
    {
        // Mantenha a lógica de animação e colliders existente
        SetInitialScaleAndPosition(track, track.transform.position);
        ApplyAnimations(track, track.transform.position);
        ScheduleDestruction(track);
    }

    private void CleanupOldTracks()
    {
        // Remove tracks que já estão muito para trás
        activeTracks.RemoveAll(track => 
            track == null || 
            track.transform.position.z < (latestEndPointZ - 100f));
    }

    private void UpdateBiome()
    {
        if (tracksGenerated > 0 && tracksGenerated % biomes[currentBiomeIndex].tracksBeforeChange == 0)
        {
            // Muda para o próximo bioma
            currentBiomeIndex = (currentBiomeIndex + 1) % biomes.Count;
            currentTracks = biomes[currentBiomeIndex].tracks;

            // Chama a mudança de bioma com um atraso
            StartCoroutine(WaitAndChangeBiome());
        }
    }


    private GameObject SelectRandomGround()
    {
        if (currentTracks.Count == 0) return null; // Evita erros se a lista estiver vazia
        int randomIndex = Random.Range(0, currentTracks.Count);
        return currentTracks[randomIndex];
    }

    private GameObject SelectRandomSingleTrack()
    {
        if (currentTracks.Count == 0) return null; // Evita erros se a lista estiver vazia
        int randomIndex = Random.Range(0, currentTracks.Count);
        return currentTracks[randomIndex].GetComponent<Ground>().track;
    }

    private Vector3 CalculateFinalPosition()
    {
        float baseXPosition = Random.Range(minimumXPosition, maximumXPosition) + transform.position.x;
        float randomXOffset = Random.Range(-xVariationRange, xVariationRange);
        float randomYOffset = Random.Range(minYVariation, maxYVariation);

        float finalYPosition = transform.position.y - randomYOffset - cumulativeYOffset;
        float finalZPosition = CalculateZPosition().z;

        cumulativeYOffset += randomYOffset;
        return new Vector3(baseXPosition + randomXOffset, finalYPosition, finalZPosition);
    }

    private Vector3 CalculateZPosition()
    {
        float startAttachPointZPosition = nextElement.GetComponent<Ground>().startAttachPoint.transform.position.z;
        float endAttachPointZPosition = lastElement.GetComponent<Ground>().endAttachPoint.transform.position.z;
        float zPositionOffset = nextElement.transform.position.z - startAttachPointZPosition;
        float finalZPosition = endAttachPointZPosition + zPositionOffset;

        return new Vector3(transform.position.x, transform.position.y, finalZPosition);
    }

    private GameObject InstantiateElement(GameObject prefab, Vector3 position)
    {
        GameObject newElement = Instantiate(prefab, position, Quaternion.identity);
        newElement.transform.parent = elementContainer.transform;
        return newElement;
    }

    private void SetInitialScaleAndPosition(GameObject element, Vector3 finalPosition)
    {
        Vector3 initialScale = element.transform.localScale;
        element.transform.localScale = initialScale * 4f; // Começa maior
        element.transform.position =
            finalPosition + new Vector3(Random.Range(-100, 100), 250, 100); // Posição inicial diagonal

        Collider[] colliders = element.GetComponentsInChildren<Collider>();
        foreach (Collider collider in colliders)
        {
            collider.enabled = false;
        }
    }

    private void ApplyAnimations(GameObject element, Vector3 finalPosition)
    {
        element.transform.DOScale(element.transform.localScale / 4f, 1f).SetEase(Ease.OutBack);
        element.transform.DOMove(finalPosition, 1f).SetEase(Ease.InQuad);

        float randomRotationZ = Random.Range(-5f, 5f);
        element.transform.DORotate(new Vector3(0, 0, randomRotationZ), 1f, RotateMode.LocalAxisAdd)
            .SetEase(Ease.OutQuad);

        element.transform.DOMove(finalPosition, 1.5f).OnComplete(() =>
        {
            Collider[] colliders = element.GetComponentsInChildren<Collider>();
            foreach (Collider collider in colliders)
            {
                collider.enabled = true;
            }
        });
    }

    private void ScheduleDestruction(GameObject element)
    {
        Destroy(element, timeToDestroy);
    }

    public void WaitAndGenerate()
    {
        StartCoroutine(WaitAndGenerateCoroutine());
    }

    private IEnumerator WaitAndGenerateCoroutine()
    {
        yield return new WaitForSeconds(timeToGenerate);
        Generate();
    }

    private void ShowBiomeName()
    {
        
        biomeText.gameObject.SetActive(true);

        // Define o texto para o nome do bioma
        biomeText.text = biomes[currentBiomeIndex].biomeName;

        // Define a cor do texto para a cor do bioma atual
        biomeText.color = biomes[currentBiomeIndex].biomeColor;

        // Pegar RectTransform do TMP
        RectTransform textRect = biomeText.GetComponent<RectTransform>();

        // Armazena a posição atual em Y (para manter o texto na altura desejada)
        float originalY = textRect.anchoredPosition.y;

        // Posicionar inicialmente fora da tela, à esquerda (apenas no eixo X)
        textRect.anchoredPosition = new Vector2(-Screen.width, originalY);

        // Criar a sequência de animações
        Sequence seq = DOTween.Sequence();

        // 1. Entrar da esquerda até o centro
        seq.Append(
            textRect.DOAnchorPos(new Vector2(0f, originalY), 1f)
                .SetEase(Ease.OutBack)
        );

        // 2. Ficar parado 2 segundos
        seq.AppendInterval(2f);

        // 3. Sair pra direita (fora da tela)
        seq.Append(
            textRect.DOAnchorPos(new Vector2(Screen.width, originalY), 1f)
                .SetEase(Ease.InQuad)
        );

        // 4. Desativar após o fim
        seq.OnComplete(() =>
        {
            biomeText.gameObject.SetActive(false);
        });
    }
    
    private void ShowBiomeParticle()
    {
        
        // Set other particles inactive
        for (int i = 0; i < biomes.Count; i++)
        {
            if (biomes[i].biomeParticle == null)
            {
                continue;
            }
            biomes[i].biomeParticle.SetActive(false);
        }
        if (biomes[currentBiomeIndex].biomeParticle == null)
        {
            return;
        }
        biomes[currentBiomeIndex].biomeParticle.SetActive(true);

    }
    
    
    private void ChangeBiomeSkybox()
    {
        RenderSettings.skybox = biomes[currentBiomeIndex].biomeSkybox;
    }
    
    private IEnumerator WaitAndChangeBiome()
    {
        // Aguarda X segundos antes de trocar
        yield return new WaitForSeconds(delayBeforeBiomeChange);

        // Anima o texto
        ShowBiomeName();
        ShowBiomeParticle();

        // Troca a Skybox
        ChangeBiomeSkybox();
    }
    

}

================
File: Assets/Elements/SmurfCat/SmurfCatMovement.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;
using UnityEngine.Serialization;
using Random = UnityEngine.Random;

public class SmurfCatMovement : MonoBehaviour
{
    [Header("Movement Settings")]
    public float horizontalSpeed = 2.0f;
    public float jumpStrength = 10.0f;
    public float maxHorizontalSpeed = 15.0f;
    private bool isFallingHighSpeed = false;
    private Animator animator;

    [Header("Game Objects")]
    public GameObject loseScreen;
    public GameObject fallingVFX;
    public GameObject groundScorchVFX;
    public GameObject fallExplosionVFX;
    public GameObject jumpSpotText;
    public GameObject grounds;
    public GameObject baseGround;
    public GameObject tutorials;
    public List<TrailRenderer> fallingTrails;

    [Header("UI Elements")]
    public TextMeshProUGUI scoreText;
    public TextMeshProUGUI scoreMultiplierText;
    // public TextMeshProUGUI highScoreText;
    [FormerlySerializedAs("fadeInDuration")] [SerializeField] private float fallingVfxFadeInDuration;
    [FormerlySerializedAs("fadeOutDuration")] [SerializeField] private float fallingVfxFadeOutDuration;
    public GameObject revivePanel;
    public GameObject halo;
    
    [Header("Hitstop Settings")]
    public float minHitstopDuration = 0.05f;
    public float maxHitstopDuration = 0.3f;
    public float minHitstopIntensity = 0.2f;
    public float maxHitstopIntensity = 0.0f;
    public float maxVelocityForScaling = 120f;
    
    public static event Action onHighFallSpeed;
    public static event Action onGroundImpact;
    public static event Action onPlayerJump;
    public static event Action onPlayerHorizontalSwipe;
    public static event Action onTrackCompleted;



    [Header("Dependencies")]
    public LevelEnd levelEnd;
    public Generator generator;
    public CameraController cameraController;

    [Header("Physics Settings")]
    public Rigidbody rb;
    public float maxYSpeed = -20.0f;
    public GameObject adsManager;
    public MoveForward moveForward;

    private float scoreMultiplier = 1.0f;
    private float currentScore = 0.0f;
    private float highScore = 0.0f;
    private Vector3 targetVelocity;
    public bool isGrounded = false;
    private bool isOnJumpSpot = false;
    private bool hadHighFallSpeed = false;
    private bool isDead = false;
    private bool isHitstopActive = false;

    private PlayerInput playerInput;
    private Vector2 startTouchPosition;
    private Vector2 endTouchPosition;
    private bool isSwipeDetected = false;
    
    private AudioManager audioManager;
    private bool _isFallingFXActive;
    private bool _isImmortal = false;
    [SerializeField] private bool _canAlrealdyJump = false;


    #region Unity Lifecycle

    private void Awake()
    {
        InitializeComponents();
        LoadHighScore();
    }
    

    private void OnEnable()
    {
        playerInput.actions.Enable();
        TutorialManager.onFirstTutorialStarted += OnFirstTutorialStarted;
        onTrackCompleted += CompleteTrack;
        void OnFirstTutorialStarted()
        {
            _canAlrealdyJump = true;
            TutorialManager.onFirstTutorialStarted -= OnFirstTutorialStarted;
        }
    }

    private void OnDisable()
    {
        playerInput.actions.Disable();
        
    }

    private void FixedUpdate()
    {
        HandleMovement();
        UpdateScore();
        CheckFallingState();
        
        if (transform.position.z > generator.LatestEndPointZ)
        {
            onTrackCompleted?.Invoke();
        }
    }

    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.CompareTag(Tags.Ground))
        {
            HandleGroundCollision(collision);
        }
    }

    // private void OnCollisionStay(Collision other)
    // {
    //     if (other.gameObject.CompareTag(Tags.Ground))
    //     {
    //         return;
    //         isGrounded = true;
    //     }
    // }
    // private void OnCollisionExit(Collision collision)
    // {
    //     if (collision.gameObject.CompareTag(Tags.Ground))
    //     {
    //         isGrounded = false;
    //     }
    // }

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag(Tags.GroundEnd))
        {
            generator.Generate();
            cameraController.SetAirborne(true);
            OnGroundEnd?.Invoke();
            
        }
        else if (other.CompareTag(Tags.JumpSpot))
        {
            isOnJumpSpot = true;
        }
    }

    public UnityEvent OnGroundEnd;

    private void OnTriggerExit(Collider other)
    {
        if (other.CompareTag(Tags.JumpSpot))
        {
            isOnJumpSpot = false;
        }
    }

    #endregion

    #region Initialization

    private void InitializeComponents()
    {
        playerInput = GetComponent<PlayerInput>();
        rb = GetComponent<Rigidbody>();
        audioManager = FindObjectOfType<AudioManager>();
        animator = GetComponent<Animator>();
        horizontalSpeed = PlayerPrefs.GetFloat(PlayerPrefsKeys.MovementSensitivity, 2.5f);


    }

    private void LoadHighScore()
    {
        return;
        highScore = PlayerPrefs.GetFloat(PlayerPrefsKeys.HighScore, 0);
        // highScoreText.text = highScore.ToString("F0");
    }

    #endregion

    #region Movement

   public void MoveHorizontally(InputAction.CallbackContext context)
{
    if (context.phase == InputActionPhase.Performed || context.phase == InputActionPhase.Canceled)
    {
        Vector2 moveInput = context.ReadValue<Vector2>();
        // Aqui, em vez de multiplicar diretamente por horizontalSpeed, calcule a velocidade com base no movimento
        float moveDeltaX = moveInput.x * horizontalSpeed;  // Aqui, moveInput.x representa a distância percorrida
        targetVelocity = new Vector3(moveDeltaX, rb.velocity.y, rb.velocity.z);
        if (Math.Abs(moveInput.x) > 15f) onPlayerHorizontalSwipe?.Invoke();

        // Agora aplicamos a limitação na velocidade para garantir que ela não ultrapasse o máximo
        // targetVelocity.x = Mathf.Clamp(targetVelocity.x, -maxHorizontalSpeed, maxHorizontalSpeed);
    }
}

private void HandleMovement()
{
    Vector3 newVelocity = new Vector3(targetVelocity.x, rb.velocity.y, rb.velocity.z);
    
    // Movimentação suave entre a velocidade atual e a nova velocidade com base na entrada
    rb.velocity = !isDead
        ? Vector3.Lerp(rb.velocity, newVelocity, horizontalSpeed * Time.fixedDeltaTime)
        : Vector3.zero;

    
    // Verificação para morte do personagem se a velocidade no eixo Y for muito negativa
    if (rb.velocity.y < -maxYSpeed)
    {
        if (isDead) return;
        isDead = true;
        cameraController.OnPlayerDeath();
        SaveHighScore();
        ShowLevelEnd();
        UnityInterstitialAd.Instace.LoadAd();

    }
}

public void SetMovementSensitivity(float sensitivity)
{
    horizontalSpeed = sensitivity;
    PlayerPrefs.SetFloat(PlayerPrefsKeys.MovementSensitivity, sensitivity);
}

    #endregion

    #region Jump

    public void OnSwipe(InputAction.CallbackContext context)
    {
        if (isDead) return;
        if (IsPointerOverUI() || !isGrounded) return;
        if (context.phase == InputActionPhase.Started)
        {
            // Registra o início do toque
            startTouchPosition = context.ReadValue<Vector2>();
        }
        else if (context.phase == InputActionPhase.Performed)
        {
            // Registra o fim do toque
            endTouchPosition = context.ReadValue<Vector2>();
            DetectSwipe();
        }
    }
    private void DetectSwipe()
    {
        Vector2 swipeDelta = endTouchPosition;

        // Verifica se o swipe é significativo
        if (swipeDelta.magnitude > 15f) // Ajuste o valor conforme necessário
        {

            float verticalSwipe = Mathf.Abs(swipeDelta.y);
            float horizontalSwipe = Mathf.Abs(swipeDelta.x);

            if (verticalSwipe > horizontalSwipe && swipeDelta.y > 0)
            {
                // Swipe para cima detectado
                isSwipeDetected = true;
                PerformJump();
                isSwipeDetected = false;
            }
        }
    }
    

    public void Jump()
    {
        return;
        /*if (IsPointerOverUI() || !isGrounded) return;

        PerformJump();

        if (isOnJumpSpot)
        {
            ProcessJumpSpot();
        }*/
    }

    private void PerformJump()
    {
        if (!_canAlrealdyJump) return;
        if (isDead) return;
        if (!isGrounded) return;
        
        onPlayerJump?.Invoke();

        isGrounded = false;
        rb.AddForce(Vector3.up * jumpStrength, ForceMode.Impulse);
        audioManager.PlayJumpSound();
        if (isOnJumpSpot)
        {
            animator.SetTrigger("JumpRoll");

            ProcessJumpSpot();
        }
        else
        {
            animator.SetTrigger("Jump");
        }
    }

    private void ProcessJumpSpot()
    {
        currentScore += 10 * scoreMultiplier;
        scoreMultiplier *= 1.1f;
        ShowJumpSpotText(10 * scoreMultiplier);
    }

    private void ShowJumpSpotText(float score)
    {
        jumpSpotText.SetActive(true);
        jumpSpotText.GetComponent<TextMeshProUGUI>().text = $"Jump Spot! +{score:F0}";
        StartCoroutine(HideJumpSpotText());
    }

    private IEnumerator HideJumpSpotText()
    {
        yield return new WaitForSeconds(2f);
        jumpSpotText.GetComponent<Juice>().Deactivate();
    }

    #endregion

    #region Score Management

    private void UpdateScore()
    {
        if (isDead) return;
        currentScore += scoreMultiplier * Time.fixedDeltaTime * 2;
        scoreMultiplier += Time.fixedDeltaTime / 150;

        scoreText.text = Mathf.FloorToInt(currentScore).ToString();
        scoreMultiplierText.text = $"x{scoreMultiplier:F2}";
    }

    private void SaveHighScore()
    {
        if (currentScore > highScore)
        {
            highScore = currentScore;
            PlayerPrefs.SetFloat(PlayerPrefsKeys.HighScore, highScore);
        }
    }

    #endregion

    #region Ground Collision

    private void HandleGroundCollision(Collision collision)
    {
        isGrounded = true;
        cameraController.SetAirborne(false);

        if (hadHighFallSpeed)
        {
            ProcessHighFallImpact(collision);
        }

        hadHighFallSpeed = false;
    }

    private void ProcessHighFallImpact(Collision collision)
    {
        SpawnCoinsOnImpact(collision);
        TriggerGroundExplosion();
        PlayImpactAudio();
        TriggerHitstopEffect();
        animator.SetBool("Falling", false);
        animator.SetTrigger("HeroLand");

        isFallingHighSpeed = false;
        Handheld.Vibrate();
        onGroundImpact?.Invoke();
    }

    private void SpawnCoinsOnImpact(Collision collision)
    {
        var spawnCoins = collision.gameObject.GetComponent<SpawnCoins>();
        spawnCoins?.StartCoroutine("DelayedSpawn");
    }

    private void TriggerGroundExplosion()
    {
        var explosion = Instantiate(fallExplosionVFX, transform.position, Quaternion.identity);
        explosion.transform.SetParent(grounds.transform);
        explosion.transform.position += Vector3.up * 2.5f;
        Destroy(explosion, 3.3f);
        
        var groundExplosion = Instantiate(groundScorchVFX, transform.position, Quaternion.identity);
        groundExplosion.transform.SetParent(grounds.transform);
        groundExplosion.transform.position += Vector3.up * 1.5f;
        Destroy(groundExplosion, 3.3f);
    }

    private void PlayImpactAudio()
    {
        audioManager.StopFallingAudio();
        audioManager.PlayRandomImpactSound();
        Handheld.Vibrate();
    }

    #endregion

    #region Falling State

    private void EnteredHighFallSpeed()
    {
        if (isFallingHighSpeed) return;
        onHighFallSpeed?.Invoke();
    }
    private void CheckFallingState()
    {
        if (rb.velocity.y < -35)
        {
            EnteredHighFallSpeed();
            isFallingHighSpeed = true;
            fallingVFX.SetActive(true);
            hadHighFallSpeed = true;
            audioManager.PlayFallingAudio();
            animator.SetBool("Falling", true);
            ActivateFallingTrails();
        }
        else
        {
            isFallingHighSpeed = false;
            fallingVFX.SetActive(false);
            DeactivateFallingTrails();
        }
    }
    private void ActivateFallingVFX()
    {
        // Se o GO estiver desativado, ative-o antes de iniciar o fade.
        fallingVFX.SetActive(true);

        CanvasGroup cg = fallingVFX.GetComponent<CanvasGroup>();
        if (cg == null)
        {
            cg = fallingVFX.AddComponent<CanvasGroup>();
        }

        cg.alpha = 0f;  // Começa invisível
        cg.DOKill();    // Cancela qualquer tween anterior, caso esteja rolando

        // Fade in
        cg.DOFade(1f, fallingVfxFadeInDuration).SetEase(Ease.OutQuad);

        _isFallingFXActive = true;
    }

    private void DeactivateFallingVFX()
    {
        CanvasGroup cg = fallingVFX.GetComponent<CanvasGroup>();
        if (cg == null)
        {
            // Se não existir, apenas desativa sem transição
            fallingVFX.SetActive(false);
            _isFallingFXActive = false;
            return;
        }

        cg.DOKill();

        // Fade out bem rápido
        cg.DOFade(0f, fallingVfxFadeOutDuration)
            .SetEase(Ease.InQuad)
            .OnComplete(() =>
            {
                // Depois do fade out, desativa GameObject
                fallingVFX.SetActive(false);
                _isFallingFXActive = false;
            });
    }
    
    private void ActivateFallingTrails()
    {
        fallingTrails.ForEach(trail => trail.emitting = true);
    }
    private void DeactivateFallingTrails()
    {
        fallingTrails.ForEach(trail => trail.emitting = false);
    }

    #endregion

    #region Hitstop Effect

    private void TriggerHitstopEffect()
    {
        float impactVelocity = Mathf.Abs(rb.velocity.y);
        float scaledDuration = Mathf.Lerp(minHitstopDuration, maxHitstopDuration, impactVelocity / maxVelocityForScaling);
        float scaledIntensity = Mathf.Lerp(minHitstopIntensity, maxHitstopIntensity, impactVelocity / maxVelocityForScaling);
        StartCoroutine(HitstopCoroutine(scaledDuration, scaledIntensity));
    }

    private IEnumerator HitstopCoroutine(float duration, float intensity)
    {
        if (isHitstopActive) yield break;

        isHitstopActive = true;
        Time.timeScale = intensity;

        yield return new WaitForSecondsRealtime(duration);

        Time.timeScale = 1.0f;
        isHitstopActive = false;
    }

    #endregion

    #region Death

    // ReSharper disable Unity.PerformanceAnalysis
    public void Die()
    {
        if (_isImmortal) return;
        isDead = true;
        animator.SetBool("IsDead", true);
        moveForward.enabled = false;

        if (Random.Range(0, 2) == 0)
        {
            animator.SetTrigger("DieNMelt");
        }
        else
        {
            animator.SetTrigger("Die");
        }
        cameraController.OnPlayerDeath();
        SaveHighScore();
        audioManager.PlayDeathSound();
        
        // ShowRevivePanel();
        
        // Play Interstitial Ad
        UnityInterstitialAd.Instace.LoadAd();
    }
    
    public void Revive()
    {
        _isImmortal = true;
        Invoke("SetIsImmortalFalse", 5f);
        isDead = false;
        animator.SetBool("IsDead", false);

        moveForward.enabled = true;
        animator.SetTrigger("Jump");
        cameraController.OnRevive();
      
        
        //  Check if the halo parent is self, if not, set it to self
        if (halo.transform.parent != transform)
        {
            halo.transform.parent = transform;
        }
        ShowAndHideHalo();
        OnRevive.Invoke();
        audioManager.PlayReviveSound();
    }
    
    // Set isImmortal false after 5 seconds
    private void SetIsImmortalFalse()
    {
        _isImmortal = false;
    }
    
    public void ShowRevivePanel()
    {
        revivePanel.SetActive(true);
    }
    
    // Show the end level panel
    public void ShowLevelEnd()
    {
        levelEnd.EndLevel();
    }
    
    private void HideHalo()
    {
        halo.transform.DOLocalMoveY(10f, .5f).SetEase(Ease.OutBounce).OnComplete(() =>
        {
            halo.SetActive(false);
        });
    }
    
    private void ShowAndHideHalo()
    {
        // Set halo position to slightly above the player
        halo.transform.position = transform.position + Vector3.up * 8f;
        // Tween the halo appearing above player head
        halo.transform.DOLocalMoveY(4f, 2f).SetEase(Ease.OutBack);
        halo.SetActive(true);
        Invoke("HideHalo",3f);
    }
    
    public UnityEvent OnRevive;

    #endregion

    #region Utility

    private bool IsPointerOverUI()
    {
        return EventSystem.current != null && EventSystem.current.IsPointerOverGameObject();
    }

    #endregion

    private static class Tags
    {
        public const string Ground = "Ground";
        public const string GroundEnd = "GroundEnd";
        public const string JumpSpot = "JumpSpot";
    }

    private static class PlayerPrefsKeys
    {
        public const string HighScore = "HighScore";
        public const string MovementSensitivity = "MovementSensitivity";

    }

    private void CompleteTrack()
    {
        generator.Generate();
        cameraController.SetAirborne(true);
    }
}



================================================================
End of Codebase
================================================================
